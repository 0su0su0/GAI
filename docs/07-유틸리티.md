# 7. 유틸리티 (Utilities)

## 목차
1. [개요](#개요)
2. [Platform Utilities - 플랫폼 감지](#platform-utilities---플랫폼-감지)
3. [Automation - GUI 자동화](#automation---gui-자동화)
4. [OCR - 광학 문자 인식](#ocr---광학-문자-인식)
5. [Permissions - 권한 관리](#permissions---권한-관리)

---

## 개요

GAI의 유틸리티 시스템은 **크로스 플랫폼 GUI 자동화를 위한 저수준 헬퍼 함수**들을 제공합니다.

**4개 카테고리**:
1. **Platform Utilities** (2개) - 플랫폼 감지, 지연 함수
2. **Automation** (3개) - 좌표 변환, 마우스 제어, 키보드 제어
3. **OCR** (3개) - OCR 인터페이스, macOS 구현, Factory
4. **Permissions** (1개) - macOS 권한 관리

**총 9개 파일** (~650 lines)

---

## Platform Utilities - 플랫폼 감지

### 2.1 platform.ts

**파일**: `src/utils/platform.ts` (48 lines)

#### 목적
Node.js `process.platform`을 래핑하여 플랫폼 감지를 단순화합니다.

#### 타입 정의

```typescript
export type Platform = 'macos' | 'windows' | 'linux' | 'unknown';
```

#### Public API

##### 1) `getPlatform(): Platform`

**목적**: 현재 플랫폼 반환

```typescript
export function getPlatform(): Platform {
  const platform = process.platform;

  if (platform === 'darwin') return 'macos';
  if (platform === 'win32') return 'windows';
  if (platform === 'linux') return 'linux';

  return 'unknown';
}
```

**매핑**:
- `darwin` → `'macos'`
- `win32` → `'windows'`
- `linux` → `'linux'`
- 기타 → `'unknown'`

**사용 예시**:
```typescript
const platform = getPlatform();
if (platform === 'macos') {
  // macOS 전용 로직
}
```

##### 2) `isOCRSupported(): boolean`

**목적**: OCR 지원 여부 확인

```typescript
export function isOCRSupported(): boolean {
  const platform = getPlatform();
  return platform === 'macos' || platform === 'windows';
}
```

**지원 플랫폼**:
- ✅ macOS (Vision Framework)
- ✅ Windows (향후 지원 예정)
- ❌ Linux (지원 없음)

##### 3) `isMacOS(): boolean`

**목적**: macOS 여부 확인

```typescript
export function isMacOS(): boolean {
  return getPlatform() === 'macos';
}
```

##### 4) `isWindows(): boolean`

**목적**: Windows 여부 확인

```typescript
export function isWindows(): boolean {
  return getPlatform() === 'windows';
}
```

##### 5) `isLinux(): boolean`

**목적**: Linux 여부 확인

```typescript
export function isLinux(): boolean {
  return getPlatform() === 'linux';
}
```

#### 사용 시나리오

```typescript
// macOS 전용 기능
if (isMacOS()) {
  MacPermissions.checkAllPermissions();
}

// OCR 지원 확인
if (isOCRSupported()) {
  const ocrProvider = OCRFactory.create();
}

// 크로스 플랫폼 처리
const platform = getPlatform();
switch (platform) {
  case 'macos':
    // macOS 로직
    break;
  case 'windows':
    // Windows 로직
    break;
  case 'linux':
    // Linux 로직
    break;
  default:
    console.warn('Unsupported platform');
}
```

---

### 2.2 delay.ts

**파일**: `src/utils/delay.ts` (7 lines)

#### 목적
비동기 지연을 위한 Promise 기반 함수입니다.

#### 구현

```typescript
export async function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

**단순하지만 필수적**:
- GUI 자동화 시 UI 안정화 대기
- 연속 액션 사이 간격 유지

#### 사용 예시

```typescript
// Spotlight 열기 후 대기
await KeyboardController.pressKey("space", ["command"]);
await delay(300); // Spotlight 열릴 때까지

// 타이핑 후 Enter 전 대기
KeyboardController.typeText("Hello");
await delay(100);
KeyboardController.pressEnter();

// NavigationBrain의 executeAction() 사이 지연
await this.executeAction(action);
await delay(500); // UI 안정화
await this.updateShadowDOM();
```

**타이밍 가이드**:
- **100-300ms**: 짧은 UI 반응 (모달, 드롭다운)
- **500ms**: 일반적인 UI 안정화 (페이지 전환)
- **1000-2000ms**: 앱 실행, 네트워크 요청

---

## Automation - GUI 자동화

Automation 유틸리티는 **nut.js 라이브러리를 래핑**하여 마우스/키보드 제어와 좌표 변환을 제공합니다.

### 3.1 CoordinateConverter

**파일**: `src/utils/automation/CoordinateConverter.ts` (68 lines)

#### 목적
**Normalized 좌표 (0.0-1.0)와 Pixel 좌표 간 변환**을 담당합니다. macOS Vision Framework는 normalized 좌표를 반환하므로 pixel 좌표로 변환이 필요합니다.

#### Static 메서드

##### 1) `getScreenSize(): { width: number; height: number }`

**목적**: 화면 해상도 조회 (캐싱)

```typescript
private static cachedScreenSize: { width: number; height: number } | null = null;

static getScreenSize(): { width: number; height: number } {
  if (!this.cachedScreenSize) {
    this.cachedScreenSize = robot.getScreenSize();
  }
  return this.cachedScreenSize;
}
```

**캐싱 이유**:
- `robot.getScreenSize()`는 system call (느림)
- 화면 해상도는 런타임 중 변경 없음
- 매번 호출 대신 한 번만 조회

**반환 예시**:
```typescript
{ width: 1920, height: 1080 }
```

##### 2) `normalizedToPixel(normalizedBBox: BoundingBox): BoundingBox`

**목적**: Normalized 좌표 → Pixel 좌표 변환

```typescript
static normalizedToPixel(normalizedBBox: BoundingBox): BoundingBox {
  const screen = this.getScreenSize();

  return {
    x: Math.round(normalizedBBox.x * screen.width),
    y: Math.round(normalizedBBox.y * screen.height),
    width: Math.round(normalizedBBox.width * screen.width),
    height: Math.round(normalizedBBox.height * screen.height),
  };
}
```

**변환 예시**:
```typescript
// 입력 (normalized, 화면 중앙)
{
  x: 0.5,
  y: 0.5,
  width: 0.1,
  height: 0.05
}

// 출력 (pixel, 1920x1080 화면)
{
  x: 960,      // 0.5 * 1920
  y: 540,      // 0.5 * 1080
  width: 192,  // 0.1 * 1920
  height: 54   // 0.05 * 1080
}
```

**Math.round() 이유**: 픽셀은 정수만 가능

##### 3) `isNormalized(bbox: BoundingBox): boolean`

**목적**: Bbox가 normalized 좌표인지 확인

```typescript
static isNormalized(bbox: BoundingBox): boolean {
  return (
    bbox.x >= 0 &&
    bbox.x <= 1 &&
    bbox.y >= 0 &&
    bbox.y <= 1 &&
    bbox.width >= 0 &&
    bbox.width <= 1 &&
    bbox.height >= 0 &&
    bbox.height <= 1
  );
}
```

**판별 로직**: 모든 값이 0.0 ~ 1.0 범위면 normalized

**예시**:
```typescript
isNormalized({ x: 0.5, y: 0.3, width: 0.1, height: 0.05 }) // true
isNormalized({ x: 500, y: 300, width: 100, height: 50 })   // false
```

##### 4) `ensurePixelCoordinates(bbox: BoundingBox): BoundingBox`

**목적**: 자동 감지 후 필요 시 변환

```typescript
static ensurePixelCoordinates(bbox: BoundingBox): BoundingBox {
  if (this.isNormalized(bbox)) {
    return this.normalizedToPixel(bbox);
  }
  return bbox;
}
```

**동작**:
1. `isNormalized()` 체크
2. Normalized면 → `normalizedToPixel()` 변환
3. 이미 pixel이면 → 그대로 반환

**사용 사례**: MouseController.clickBBoxCenter()
```typescript
static clickBBoxCenter(bbox: BoundingBox, ...): void {
  // 안전 장치: OCR이 normalized를 반환할 수도 있음
  const pixelBBox = CoordinateConverter.ensurePixelCoordinates(bbox);

  const centerX = Math.round(pixelBBox.x + pixelBBox.width / 2);
  const centerY = Math.round(pixelBBox.y + pixelBBox.height / 2);
  this.clickAt(centerX, centerY, button, doubleClick);
}
```

#### 의존성
- `robotjs`: getScreenSize()
- `core/types.ts`: BoundingBox

---

### 3.2 MouseController

**파일**: `src/utils/automation/MouseController.ts` (118 lines)

#### 목적
**nut.js 라이브러리를 래핑하여 마우스 제어**를 제공합니다. 클릭, 이동, 드래그, 스크롤을 지원합니다.

#### Private 메서드

##### `toNutButton(button: 'left' | 'right' | 'middle'): Button`

**목적**: 문자열 → nut.js Button enum 변환

```typescript
private static toNutButton(button: 'left' | 'right' | 'middle'): Button {
  switch (button) {
    case 'left':
      return Button.LEFT;
    case 'right':
      return Button.RIGHT;
    case 'middle':
      return Button.MIDDLE;
  }
}
```

**nut.js Button enum**:
- `Button.LEFT` (0)
- `Button.RIGHT` (1)
- `Button.MIDDLE` (2)

#### Public 메서드

##### 1) `clickAt(x, y, button?, doubleClick?): void`

**목적**: 특정 좌표 클릭

```typescript
static clickAt(
  x: number,
  y: number,
  button: 'left' | 'right' | 'middle' = 'left',
  doubleClick: boolean = false
): void {
  const point = new Point(x, y);
  const nutButton = this.toNutButton(button);

  // 1. 마우스 이동
  mouse.setPosition(point);

  // 2. 클릭
  if (doubleClick) {
    mouse.doubleClick(nutButton);
  } else {
    mouse.click(nutButton);
  }
}
```

**단계**:
1. **Point 생성**: `new Point(x, y)` (nut.js 타입)
2. **마우스 이동**: `mouse.setPosition(point)`
3. **클릭**: `mouse.click()` 또는 `mouse.doubleClick()`

**사용 예시**:
```typescript
// 왼쪽 클릭
MouseController.clickAt(500, 300);

// 오른쪽 더블클릭
MouseController.clickAt(100, 200, 'right', true);
```

##### 2) `clickBBoxCenter(bbox, button?, doubleClick?): void`

**목적**: Bounding box 중심 클릭

```typescript
static clickBBoxCenter(
  bbox: BoundingBox,
  button: 'left' | 'right' | 'middle' = 'left',
  doubleClick: boolean = false
): void {
  // 1. Normalized → Pixel 변환 (필요 시)
  const pixelBBox = CoordinateConverter.ensurePixelCoordinates(bbox);

  // 2. 중심 좌표 계산
  const centerX = Math.round(pixelBBox.x + pixelBBox.width / 2);
  const centerY = Math.round(pixelBBox.y + pixelBBox.height / 2);

  // 3. 클릭
  this.clickAt(centerX, centerY, button, doubleClick);
}
```

**단계**:
1. **좌표 변환**: `ensurePixelCoordinates()` - normalized면 pixel로 변환
2. **중심 계산**: `x + width/2`, `y + height/2`
3. **클릭**: `clickAt()` 호출

**사용 사례**: OCR로 찾은 텍스트 클릭
```typescript
// OCR 결과
const ocrResult = {
  text: "Login",
  bbox: { x: 100, y: 200, width: 80, height: 30 }
};

// 중심(140, 215) 클릭
MouseController.clickBBoxCenter(ocrResult.bbox);
```

##### 3) `moveTo(x, y): void`

**목적**: 마우스 이동 (클릭 없음)

```typescript
static moveTo(x: number, y: number): void {
  const point = new Point(x, y);
  mouse.setPosition(point);
}
```

##### 4) `getPosition(): { x: number; y: number }`

**목적**: 현재 마우스 위치 조회

```typescript
static getPosition(): { x: number; y: number } {
  const position = mouse.getPosition();
  return { x: position.x, y: position.y };
}
```

**사용 예시**:
```typescript
const pos = MouseController.getPosition();
console.log(`마우스 위치: (${pos.x}, ${pos.y})`);
```

##### 5) `drag(fromX, fromY, toX, toY, button?): void`

**목적**: 드래그 (버튼 누른 채 이동)

```typescript
static drag(
  fromX: number,
  fromY: number,
  toX: number,
  toY: number,
  button: 'left' | 'right' | 'middle' = 'left'
): void {
  const fromPoint = new Point(fromX, fromY);
  const toPoint = new Point(toX, toY);
  const nutButton = this.toNutButton(button);

  // 1. 시작 위치로 이동
  mouse.setPosition(fromPoint);

  // 2. 버튼 누르기
  mouse.pressButton(nutButton);

  // 3. 끝 위치로 이동
  mouse.move([toPoint]);

  // 4. 버튼 떼기
  mouse.releaseButton(nutButton);
}
```

**단계**:
1. **시작 위치로 이동**
2. **버튼 누름** (`pressButton`)
3. **끝 위치로 이동** (`move`)
4. **버튼 뗌** (`releaseButton`)

**사용 예시**:
```typescript
// (100, 100)에서 (500, 500)까지 드래그
MouseController.drag(100, 100, 500, 500, 'left');
```

##### 6) `scroll(amount, direction?): void`

**목적**: 수직 스크롤

```typescript
static scroll(amount: number, direction: 'up' | 'down' = 'down'): void {
  const scrollAmount = direction === 'down' ? -amount : amount;
  mouse.scrollDown(Math.abs(scrollAmount));
}
```

**파라미터**:
- `amount`: 스크롤 양 (양수)
- `direction`: 'up' 또는 'down'

**주의**: `mouse.scrollDown()`은 음수면 위로 스크롤

#### 의존성
- `@nut-tree-fork/nut-js`: mouse
- `@nut-tree-fork/shared`: Point, Button
- `CoordinateConverter`: ensurePixelCoordinates()

---

### 3.3 KeyboardController

**파일**: `src/utils/automation/KeyboardController.ts` (193 lines)

#### 목적
**nut.js 라이브러리를 래핑하여 키보드 제어**를 제공합니다. 텍스트 입력, 키 조합, 단축키를 지원합니다.

#### Private 메서드

##### `toNutKey(key: string): Key`

**목적**: 문자열 → nut.js Key enum 변환

```typescript
private static toNutKey(key: string): Key {
  const keyMap: Record<string, Key> = {
    enter: Key.Enter,
    return: Key.Enter,
    backspace: Key.Backspace,
    delete: Key.Delete,
    escape: Key.Escape,
    tab: Key.Tab,
    space: Key.Space,
    command: Key.LeftCmd,
    cmd: Key.LeftCmd,
    control: Key.LeftControl,
    ctrl: Key.LeftControl,
    alt: Key.LeftAlt,
    option: Key.LeftAlt,
    shift: Key.LeftShift,
    a: Key.A,
    b: Key.B,
    // ... z까지
  };

  return keyMap[key.toLowerCase()] || Key[key as keyof typeof Key];
}
```

**매핑 예시**:
- `'enter'`, `'return'` → `Key.Enter`
- `'cmd'`, `'command'` → `Key.LeftCmd`
- `'a'` → `Key.A`

**Fallback**: keyMap에 없으면 `Key[key]` 시도

##### `normalizeModifiers(modifiers): string[]`

**목적**: 크로스 플랫폼 modifier 변환

```typescript
private static normalizeModifiers(
  modifiers: Array<"command" | "ctrl" | "alt" | "shift">,
): string[] {
  return modifiers.map((modifier) => {
    if (modifier === "command") {
      // macOS → 'command', 기타 → 'control'
      return isMacOS() ? "command" : "control";
    }
    if (modifier === "ctrl") {
      return "control";
    }
    return modifier;
  });
}
```

**크로스 플랫폼 처리**:
- macOS: `Cmd` (Command 키)
- Windows/Linux: `Ctrl` (Control 키)

**예시**:
```typescript
// macOS
normalizeModifiers(['command', 'shift']) // ['command', 'shift']

// Windows
normalizeModifiers(['command', 'shift']) // ['control', 'shift']
```

**이유**: macOS의 Cmd는 Windows의 Ctrl과 동일한 역할

#### Public 메서드

##### 1) `typeText(text, delay?): Promise<void>`

**목적**: 텍스트 타이핑

```typescript
static async typeText(text: string, _delay: number = 50): Promise<void> {
  // nut.js의 keyboard.type은 자동으로 텍스트 입력
  await keyboard.type(text);
}
```

**특징**:
- `delay` 파라미터는 사용하지 않음 (nut.js가 자동 처리)
- 대문자, 특수문자 자동 지원

**사용 예시**:
```typescript
await KeyboardController.typeText("Hello World!");
await KeyboardController.typeText("user@example.com");
```

##### 2) `pressKey(key, modifiers?): Promise<void>`

**목적**: 키 또는 키 조합 누르기

```typescript
static async pressKey(
  key: string | string[],
  modifiers?: Array<"command" | "ctrl" | "alt" | "shift">,
): Promise<void> {
  const keys = Array.isArray(key) ? key : [key];
  const normalizedModifiers = this.normalizeModifiers(modifiers || []);

  // Convert to nut.js Keys
  const nutModifiers = normalizedModifiers.map((m) => this.toNutKey(m));
  const nutKeys = keys.map((k) => this.toNutKey(k));

  // 1. Press modifiers
  for (const modifier of nutModifiers) {
    await keyboard.pressKey(modifier);
  }

  // 2. OS가 modifier 인식할 시간
  if (nutModifiers.length > 0) {
    await sleep(50);
  }

  // 3. Press and release main keys
  for (const nutKey of nutKeys) {
    await keyboard.pressKey(nutKey);
    await sleep(20);
    await keyboard.releaseKey(nutKey);
  }

  // 4. Release modifiers 전 대기
  if (nutModifiers.length > 0) {
    await sleep(10);
  }

  // 5. Release modifiers
  for (const modifier of nutModifiers) {
    await keyboard.releaseKey(modifier);
  }
}
```

**단계별 설명**:
1. **Modifiers 누름**: Command, Ctrl, Alt, Shift
2. **50ms 대기**: OS가 modifier 상태 인식
3. **Main key 누름/뗌**: 각 키마다 20ms 간격
4. **10ms 대기**: Modifier 해제 전 안정화
5. **Modifiers 뗌**: 역순으로 해제

**타이밍이 중요한 이유**:
- Modifier 인식 전에 main key를 누르면 조합 실패
- 너무 빨리 해제하면 OS가 단축키로 인식 못함

**사용 예시**:
```typescript
// Cmd+C (복사)
await KeyboardController.pressKey('c', ['command']);

// Ctrl+Shift+T (탭 복원)
await KeyboardController.pressKey('t', ['ctrl', 'shift']);

// Escape
await KeyboardController.pressKey('escape');
```

##### 3) `keyDown(key): Promise<void>`

**목적**: 키 누르기 (계속 누른 상태 유지)

```typescript
static async keyDown(key: string): Promise<void> {
  const nutKey = this.toNutKey(key);
  await keyboard.pressKey(nutKey);
}
```

##### 4) `keyUp(key): Promise<void>`

**목적**: 키 떼기

```typescript
static async keyUp(key: string): Promise<void> {
  const nutKey = this.toNutKey(key);
  await keyboard.releaseKey(nutKey);
}
```

**사용 예시** (수동 조합):
```typescript
// Cmd 누르기
await KeyboardController.keyDown('command');
await delay(100);

// A 누르기 (전체 선택)
await KeyboardController.pressKey('a');

// Cmd 떼기
await KeyboardController.keyUp('command');
```

##### 5) `pressTab(reverse?): Promise<void>`

**목적**: Tab 키 누르기

```typescript
static async pressTab(reverse: boolean = false): Promise<void> {
  if (reverse) {
    await this.pressKey("tab", ["shift"]);
  } else {
    await keyboard.pressKey(Key.Tab);
    await keyboard.releaseKey(Key.Tab);
  }
}
```

**reverse=true**: Shift+Tab (역방향 네비게이션)

##### 6) `pressEnter(): Promise<void>`

**목적**: Enter 키 누르기

```typescript
static async pressEnter(): Promise<void> {
  await keyboard.pressKey(Key.Enter);
  await keyboard.releaseKey(Key.Enter);
}
```

##### 7) `pressEscape(): Promise<void>`

**목적**: Escape 키 누르기

```typescript
static async pressEscape(): Promise<void> {
  await keyboard.pressKey(Key.Escape);
  await keyboard.releaseKey(Key.Escape);
}
```

#### shortcuts (Static 객체)

**목적**: 자주 사용하는 단축키 모음

```typescript
static shortcuts = {
  copy: () => KeyboardController.pressKey("c", ["command"]),
  paste: () => KeyboardController.pressKey("v", ["command"]),
  cut: () => KeyboardController.pressKey("x", ["command"]),
  undo: () => KeyboardController.pressKey("z", ["command"]),
  redo: () => KeyboardController.pressKey("z", ["command", "shift"]),
  selectAll: () => KeyboardController.pressKey("a", ["command"]),
  save: () => KeyboardController.pressKey("s", ["command"]),
  find: () => KeyboardController.pressKey("f", ["command"]),
};
```

**사용 예시**:
```typescript
// 전체 선택 후 복사
await KeyboardController.shortcuts.selectAll();
await delay(100);
await KeyboardController.shortcuts.copy();
```

#### 의존성
- `@nut-tree-fork/nut-js`: keyboard, sleep
- `@nut-tree-fork/shared`: Key
- `utils/platform.ts`: isMacOS()

---

## OCR - 광학 문자 인식

OCR 시스템은 **Factory Pattern**으로 플랫폼별 구현을 제공합니다.

### 4.1 OCRProvider (Interface)

**파일**: `src/utils/ocr/OCRProvider.ts` (33 lines)

#### 목적
OCR provider의 **추상 인터페이스**를 정의합니다.

#### 인터페이스 정의

```typescript
export interface OCRProvider {
  /**
   * 이미지 파일 경로로 OCR 수행
   */
  analyze(imagePath: string): Promise<OCRAnalysis>;

  /**
   * Buffer로 OCR 수행
   */
  analyzeBuffer(imageBuffer: Buffer): Promise<OCRAnalysis>;

  /**
   * OCR 가용성 확인
   */
  isAvailable(): Promise<boolean>;

  /**
   * 지원 플랫폼 반환
   */
  getPlatform(): 'macos' | 'windows' | 'unsupported';
}
```

**메서드**:
1. `analyze(imagePath)`: 파일 경로로 OCR
2. `analyzeBuffer(imageBuffer)`: Buffer로 OCR
3. `isAvailable()`: 사용 가능 여부
4. `getPlatform()`: 플랫폼 정보

---

### 4.2 MacOCRProvider

**파일**: `src/utils/ocr/MacOCRProvider.ts` (119 lines)

#### 목적
**macOS Vision Framework를 사용한 OCR 구현**입니다.

#### 의존성
- `@cherrystudio/mac-system-ocr`: macOS Vision Framework 래퍼
- `CoordinateConverter`: Normalized → Pixel 변환

#### analyze(imagePath) 메서드

```typescript
async analyze(imagePath: string): Promise<OCRAnalysis> {
  // 1. macOS 확인
  if (!this.isAvailable()) {
    throw new Error('MacOCRProvider is only available on macOS');
  }

  try {
    // 2. Vision Framework 호출
    const result = await macOCR.recognizeFromPath(imagePath);

    // 3. fullText 추출
    const fullText = result.text || '';

    // 4. observations → OCRResult[] 변환
    const elements: OCRResult[] = [];

    if (result.observations && Array.isArray(result.observations)) {
      for (const obs of result.observations) {
        elements.push({
          text: obs.text || '',
          confidence: obs.confidence || 0,
          // Normalized → Pixel 변환
          bbox: CoordinateConverter.normalizedToPixel({
            x: obs.x || 0,
            y: obs.y || 0,
            width: obs.width || 0,
            height: obs.height || 0,
          }),
        });
      }
    }

    // 5. 결과 반환
    return {
      fullText,
      elements,
      platform: 'macos',
    };
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`macOS OCR failed: ${message}`);
  }
}
```

**단계별 설명**:
1. **플랫폼 확인**: macOS 아니면 에러
2. **Vision Framework**: `macOCR.recognizeFromPath()` 호출
3. **fullText**: 전체 텍스트 추출
4. **observations 변환**:
   - 각 observation → OCRResult
   - **Normalized → Pixel 변환** (중요!)
5. **OCRAnalysis 반환**: fullText, elements, platform

**Vision Framework의 Normalized 좌표**:
- macOS Vision Framework는 **0.0 ~ 1.0 범위의 좌표** 반환
- 이를 **pixel 좌표로 변환**해야 MouseController가 사용 가능
- `CoordinateConverter.normalizedToPixel()` 사용

#### analyzeBuffer(imageBuffer) 메서드

```typescript
async analyzeBuffer(imageBuffer: Buffer): Promise<OCRAnalysis> {
  if (!this.isAvailable()) {
    throw new Error('MacOCRProvider is only available on macOS');
  }

  try {
    // Buffer로 OCR 수행
    const result = await macOCR.recognizeFromBuffer(imageBuffer);

    // 이하 analyze()와 동일한 로직
    // ...
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`macOS OCR failed: ${message}`);
  }
}
```

**차이점**: `recognizeFromPath()` 대신 `recognizeFromBuffer()` 사용

#### isAvailable() 메서드

```typescript
async isAvailable(): Promise<boolean> {
  return isMacOS();
}
```

**단순**: macOS면 사용 가능

#### getPlatform() 메서드

```typescript
getPlatform(): 'macos' {
  return 'macos';
}
```

#### OCRAnalysis 구조

```typescript
interface OCRAnalysis {
  fullText: string;        // 전체 텍스트
  elements: OCRResult[];   // 개별 텍스트 요소
  platform?: string;       // 'macos'
}

interface OCRResult {
  text: string;            // 텍스트
  confidence: number;      // 신뢰도 (0.0 ~ 1.0)
  bbox?: BoundingBox;      // Pixel 좌표
}
```

**사용 예시**:
```typescript
const provider = new MacOCRProvider();
const result = await provider.analyze('/path/to/screenshot.png');

console.log(result.fullText); // "Login Username Password"
console.log(result.elements);
// [
//   { text: "Login", confidence: 0.95, bbox: {x: 100, y: 50, width: 80, height: 30} },
//   { text: "Username", confidence: 0.92, bbox: {x: 100, y: 100, width: 120, height: 25} },
//   ...
// ]
```

---

### 4.3 OCRFactory

**파일**: `src/utils/ocr/OCRFactory.ts` (42 lines)

#### 목적
**Factory Pattern**으로 플랫폼에 맞는 OCR Provider를 생성합니다.

#### Static 메서드

##### 1) `create(): OCRProvider | null`

**목적**: 현재 플랫폼에 맞는 OCR Provider 생성

```typescript
static create(): OCRProvider | null {
  const platform = getPlatform();

  if (platform === 'macos') {
    return new MacOCRProvider();
  }

  // TODO: Windows 지원 추가 예정
  // if (platform === 'windows') {
  //   return new WindowsOCRProvider();
  // }

  // 지원하지 않는 플랫폼
  console.warn(`No OCR provider available for platform: ${platform}`);
  return null;
}
```

**플랫폼별 Provider**:
- **macOS**: MacOCRProvider (Vision Framework)
- **Windows**: 향후 구현 예정
- **Linux**: 지원 없음 → null

##### 2) `isSupported(): boolean`

**목적**: OCR 지원 여부 확인

```typescript
static isSupported(): boolean {
  const platform = getPlatform();
  return platform === 'macos'; // || platform === 'windows' (향후)
}
```

**현재**: macOS만 지원

#### 사용 예시

```typescript
// 1. 지원 여부 확인
if (!OCRFactory.isSupported()) {
  console.error('OCR is not supported on this platform');
  process.exit(1);
}

// 2. Provider 생성
const ocrProvider = OCRFactory.create();
if (!ocrProvider) {
  console.error('Failed to create OCR provider');
  process.exit(1);
}

// 3. OCR 수행
const result = await ocrProvider.analyze('/path/to/image.png');
console.log(result.fullText);
```

**Tool에서의 사용**:
```typescript
// OCRTool.execute()
if (!OCRFactory.isSupported()) {
  return { success: false, error: 'OCR is not supported on this platform.' };
}

const ocrProvider = OCRFactory.create();
if (!ocrProvider) {
  return { success: false, error: 'Failed to create OCR provider' };
}

const result = await ocrProvider.analyze(imagePath);
```

---

## Permissions - 권한 관리

### 5.1 MacPermissions

**파일**: `src/utils/permissions/MacPermissions.ts` (103 lines)

#### 목적
**macOS 시스템 권한 관리**를 담당합니다. Accessibility와 Screen Recording 권한이 필요합니다.

#### 의존성
- `node-mac-permissions`: macOS 권한 API 래퍼
- `utils/platform.ts`: isMacOS()

#### 타입 정의

```typescript
export type PermissionStatus = 'authorized' | 'denied' | 'restricted' | 'not determined';
```

**권한 상태**:
- `'authorized'`: 허용됨
- `'denied'`: 거부됨
- `'restricted'`: 제한됨 (관리자 정책)
- `'not determined'`: 미결정 (아직 요청하지 않음)

#### Static 메서드

##### 1) `checkAccessibility(): PermissionStatus`

**목적**: Accessibility 권한 확인

```typescript
static checkAccessibility(): PermissionStatus {
  if (!isMacOS()) {
    return 'not determined';
  }

  return permissions.getAuthStatus('accessibility') as PermissionStatus;
}
```

**Accessibility 권한**:
- 마우스/키보드 제어 필요
- nut.js가 GUI 자동화에 사용

##### 2) `requestAccessibility(): void`

**목적**: Accessibility 권한 요청

```typescript
static requestAccessibility(): void {
  if (!isMacOS()) {
    console.warn('Accessibility permissions are only required on macOS');
    return;
  }

  if (this.checkAccessibility() !== 'authorized') {
    permissions.askForAccessibilityAccess();
    console.log('Please grant Accessibility permission in System Preferences');
  }
}
```

**동작**:
- 이미 허용되었으면 무시
- 아니면 System Preferences 열기
- 사용자가 수동으로 권한 부여 필요

**macOS UI**:
```
System Preferences → Security & Privacy → Privacy → Accessibility
→ [앱 이름] 체크
```

##### 3) `checkScreenRecording(): PermissionStatus`

**목적**: Screen Recording 권한 확인

```typescript
static checkScreenRecording(): PermissionStatus {
  if (!isMacOS()) {
    return 'not determined';
  }

  return permissions.getAuthStatus('screen') as PermissionStatus;
}
```

**Screen Recording 권한**:
- 화면 캡처 필요
- robotjs, nut.js 스크린샷에 사용

##### 4) `requestScreenRecording(): void`

**목적**: Screen Recording 권한 요청

```typescript
static requestScreenRecording(): void {
  if (!isMacOS()) {
    console.warn('Screen Recording permissions are only required on macOS');
    return;
  }

  console.log('Screen Recording permission will be requested on first screen capture');
  console.log('Please grant Screen Recording permission when prompted');
}
```

**특징**:
- 실제 화면 캡처 시도해야 권한 다이얼로그 표시
- 미리 요청 불가 (macOS 제약)

##### 5) `checkAllPermissions(): { ... }`

**목적**: 모든 권한 확인

```typescript
static checkAllPermissions(): {
  accessibility: PermissionStatus;
  screenRecording: PermissionStatus;
  allGranted: boolean;
} {
  const accessibility = this.checkAccessibility();
  const screenRecording = this.checkScreenRecording();

  return {
    accessibility,
    screenRecording,
    allGranted: accessibility === 'authorized' && screenRecording === 'authorized',
  };
}
```

**반환 예시**:
```typescript
{
  accessibility: 'authorized',
  screenRecording: 'denied',
  allGranted: false
}
```

##### 6) `requestAllPermissions(): void`

**목적**: 모든 권한 요청 (UI 안내 포함)

```typescript
static requestAllPermissions(): void {
  if (!isMacOS()) {
    console.warn('Permissions are only required on macOS');
    return;
  }

  console.log('\n=== macOS Permissions Required ===');
  console.log('This application needs the following permissions:');
  console.log('1. Accessibility - to control mouse and keyboard');
  console.log('2. Screen Recording - to capture screen');
  console.log('==================================\n');

  this.requestAccessibility();
  this.requestScreenRecording();
}
```

**출력 예시**:
```
=== macOS Permissions Required ===
This application needs the following permissions:
1. Accessibility - to control mouse and keyboard
2. Screen Recording - to capture screen
==================================

Please grant Accessibility permission in System Preferences
Screen Recording permission will be requested on first screen capture
Please grant Screen Recording permission when prompted
```

#### 초기화 시 권한 체크 (index.ts)

```typescript
// macOS에서만 권한 체크
if (isMacOS()) {
  const permissions = MacPermissions.checkAllPermissions();

  if (!permissions.allGranted) {
    console.error('\n❌ Required permissions not granted');
    console.error(`   Accessibility: ${permissions.accessibility}`);
    console.error(`   Screen Recording: ${permissions.screenRecording}\n`);

    MacPermissions.requestAllPermissions();

    console.error('Please restart the application after granting permissions.\n');
    process.exit(1);
  }

  console.log('✓ All required permissions granted\n');
}
```

**프로세스**:
1. 권한 확인
2. 부족하면 에러 메시지 + 요청 안내
3. 앱 종료
4. 사용자가 권한 부여 후 재실행

---

## 정리

### 파일 구조 및 크기

| 카테고리 | 파일 | 라인 수 | 설명 |
|----------|------|---------|------|
| **Platform** | platform.ts | 48 | 플랫폼 감지 |
| | delay.ts | 7 | 비동기 지연 |
| **Automation** | CoordinateConverter.ts | 68 | 좌표 변환 |
| | MouseController.ts | 118 | 마우스 제어 |
| | KeyboardController.ts | 193 | 키보드 제어 |
| **OCR** | OCRProvider.ts | 33 | OCR 인터페이스 |
| | MacOCRProvider.ts | 119 | macOS OCR 구현 |
| | OCRFactory.ts | 42 | OCR Factory |
| **Permissions** | MacPermissions.ts | 103 | macOS 권한 관리 |
| **총계** | | **731 lines** | |

### 핵심 개념

1. **Platform Detection**:
   - `getPlatform()`, `isMacOS()`, `isWindows()`, `isLinux()`
   - OCR 지원 여부 확인

2. **Coordinate Conversion**:
   - Normalized (0.0-1.0) ↔ Pixel 변환
   - `ensurePixelCoordinates()` 자동 감지
   - macOS Vision Framework의 normalized 좌표 → pixel 변환

3. **Mouse Control** (nut.js):
   - clickAt(), clickBBoxCenter()
   - moveTo(), drag(), scroll()
   - Button enum 변환 (left/right/middle)

4. **Keyboard Control** (nut.js):
   - typeText(), pressKey()
   - Modifier keys (command/ctrl/alt/shift)
   - 크로스 플랫폼 modifier 변환
   - 타이밍 제어 (50ms, 20ms, 10ms)

5. **OCR System**:
   - Factory Pattern (플랫폼별 구현)
   - macOS Vision Framework 사용
   - Normalized → Pixel 좌표 변환
   - fullText + elements 반환

6. **Permissions** (macOS):
   - Accessibility (마우스/키보드 제어)
   - Screen Recording (화면 캡처)
   - 권한 상태 확인 및 요청

### 의존성 라이브러리

| 라이브러리 | 용도 | 사용 위치 |
|-----------|------|----------|
| `robotjs` | 화면 크기 조회 | CoordinateConverter |
| `@nut-tree-fork/nut-js` | 마우스/키보드 제어 | MouseController, KeyboardController |
| `@nut-tree-fork/shared` | Point, Button, Key enum | MouseController, KeyboardController |
| `@cherrystudio/mac-system-ocr` | macOS Vision Framework OCR | MacOCRProvider |
| `node-mac-permissions` | macOS 권한 API | MacPermissions |

### 크로스 플랫폼 지원

| 기능 | macOS | Windows | Linux |
|------|-------|---------|-------|
| Platform Detection | ✅ | ✅ | ✅ |
| Mouse Control | ✅ | ✅ | ✅ |
| Keyboard Control | ✅ | ✅ | ✅ |
| OCR | ✅ | ⏳ (향후) | ❌ |
| Permissions | ✅ | ❌ | ❌ |

**현재 주요 플랫폼**: macOS
**향후 계획**: Windows OCR 추가
