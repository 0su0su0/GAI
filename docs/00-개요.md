# GAI 프로젝트 개요

> ⚠️ **문서 작성 주의사항**
> 이 문서는 Claude를 사용하여 초안을 작성한 것으로, 제작자의 의도가 완벽히 담기지 않았을 수 있습니다.
> **코드 자체도 미완성 상태**이므로, 참고용으로만 사용하시기 바랍니다.

## 목차

1. [프로젝트 소개](#프로젝트-소개)
2. [핵심 기능](#핵심-기능)
3. [기술 스택](#기술-스택)
4. [프로젝트 구조](#프로젝트-구조)
5. [주요 컴포넌트](#주요-컴포넌트)
6. [실행 흐름](#실행-흐름)
7. [문서 구조](#문서-구조)
8. [핵심 통찰](#핵심-통찰)
9. [확장 가능성](#확장-가능성)

---

## 프로젝트 소개

### 목적

**GAI (Graphic Agent Interface)**는 Vision Language Model(VLM)과 OCR을 활용하여 GUI를 자동으로 이해하고 조작하는 에이전트 시스템입니다.

주요 목적:
- **비전 LLM과 OCR을 활용한 GUI 자동화**
- **화면 네비게이션 경로 학습 및 재사용**
- **도구 호출 기반 에이전트 루프**
- **비용 최적화** (VLM 호출 최소화)

### 배경

MCP(Model Context Protocol)가 지원되지 않는 서비스에서도 에이전트가 GUI를 통해 직접 상호작용할 수 있도록 설계되었습니다. 예를 들어:
- 레거시 데스크톱 애플리케이션
- MCP 미지원 웹 서비스
- macOS/Windows 시스템 설정

### 핵심 아이디어

1. **한 번 학습, 여러 번 재사용**: VLM이 GUI 경로를 한 번 학습하면 JSON에 저장하여 다음번에는 VLM 호출 없이 바로 실행
2. **OCR + VLM 시너지**: OCR로 텍스트를 정확하게 추출하고, VLM으로 시각적 요소(버튼, 아이콘)를 인식
3. **멀티모드 최적화**: 작업에 따라 적절한 LLM 선택 (Default/Fast/Vision)

---

## 핵심 기능

### 1. 네비게이션 브레인 (Navigation Brain)

VLM이 GUI 경로를 학습하여 그래프 구조로 저장합니다.

**주요 특징**:
- **첫 방문**: VLM 분석 + 액션 시퀀스 생성 (3-5초, 비용 발생)
- **재방문**: 저장된 경로 재사용 (<2초, VLM 미사용)
- **영속성**: `data/brain/navigation.json`에 그래프 저장
- **검증**: 각 액션 후 OCR

**예시**:
```
첫 방문: "시스템 환경설정 → 디스플레이"
  → VLM 분석 → [click("System Preferences"), wait(500), click("Display")]
  → JSON 저장

재방문: "다시 디스플레이로"
  → JSON에서 경로 로드 → 바로 실행
  → 비용 100% 절감!
```

### 2. 멀티모드 LLM 시스템

작업에 따라 적절한 LLM을 선택하여 성능을 최적화합니다.

| 모드 | Ollama 모델 예시 | 용도 |
|------|-----------------|------|
| **Default** | gpt-oss:120b | 일반 에이전트 루프 |
| **Fast** | gpt-oss:20b | 빠른 작업 처리 |
| **Vision** | qwen2.5vl:32b | 화면 분석, 경로 학습 |

**주의**: 위 예시는 Ollama 로컬 모델 기준입니다. Anthropic, OpenAI, Google 등 다른 제공자도 사용 가능합니다.

**Fallback 시스템**:
- FAST/VISION이 설정되지 않으면 DEFAULT 사용
- 유연한 설정 (단일 모드 또는 멀티모드)

### 3. 12개의 GUI 도구

| 카테고리 | 도구 이름 | 개수 | 설명 |
|----------|-----------|------|------|
| **Vision Tools** | SmartScreenReader, ScreenCapture, OCR, ScreenReader | 4개 | 화면 이해 |
| **Action Tools** | Click, Type, KeyPress, TabNavigate, Spotlight | 5개 | GUI 조작 |
| **Brain Tools** | NavigateTo, GetCurrentNode, LaunchApp | 3개 | 지능형 네비게이션 |

### 4. 크로스 플랫폼 지원

- **macOS**: 완전 지원 (Vision Framework OCR, Accessibility API)
- **Windows**: 개발 예정 (Windows.Media.Ocr)

---

## 기술 스택

### 언어 및 프레임워크
- **TypeScript** (strict mode)
- **Node.js 18+**

### LLM 제공자
- **Anthropic** (Claude) - 도구 호출 완전 지원
- **OpenAI** (GPT) - 도구 호출 완전 지원
- **Google** (Gemini) - 도구 호출 미지원 (텍스트만)
- **Ollama** (로컬 모델) - 도구 호출 미지원 (텍스트만)

### GUI 자동화
- **nut.js** (`@nut-tree-fork/nut-js`) - 마우스, 키보드 제어
- **robotjs** (대체 라이브러리, 현재 미사용)

### OCR
- **macOS Vision Framework** (`@cherrystudio/mac-system-ocr`)
- **Tesseract** (Windows용 개발 예정)

### 권한 관리
- **node-mac-permissions** - macOS Accessibility, Screen Recording 권한

### 기타
- **SHA-256** - 상태 해싱 (crypto 모듈)
- **JSON** - 네비게이션 그래프 영속화

---

## 프로젝트 구조

```
GAI/  (43개 파일, ~6,113줄)
├── src/
│   ├── core/           (3개 파일)   - Agent, ToolRegistry, types
│   ├── brain/          (7개 파일)   - NavigationBrain (⭐ 757줄)
│   ├── llm/            (9개 파일)   - LLMManager + 4개 제공자
│   ├── tools/          (13개 파일)  - 12개 도구
│   ├── config/         (1개 파일)   - ConfigLoader (300줄)
│   ├── utils/          (9개 파일)   - Automation, OCR, Permissions
│   └── index.ts        (178줄)      - 진입점
├── data/brain/navigation.json       - 학습된 그래프
├── config/config.json               - 설정 파일 (선택)
├── docs/                            - 10개 문서
└── .env                             - 환경변수
```

### 모듈별 라인 수

| 모듈 | 파일 수 | 총 라인 수 | 주요 파일 |
|------|---------|------------|-----------|
| **brain** | 7 | ~1,840 | NavigationBrain.ts (757줄) |
| **llm** | 9 | ~1,469 | 4개 제공자 (평균 262줄) |
| **tools** | 13 | ~1,150 | Click, SmartScreenReader |
| **utils** | 9 | ~616 | MouseController, KeyboardController |
| **config** | 1 | 300 | ConfigLoader.ts |
| **core** | 3 | 458 | Agent, ToolRegistry, types |
| **index** | 1 | 178 | index.ts |
| **총계** | 43 | ~6,113 | - |

---

## 주요 컴포넌트

### 1. 코어 시스템

#### Agent (156줄)
- **역할**: 에이전트 루프 오케스트레이터
- **최대 반복**: 10회
- **주요 메서드**:
  - `processRequest(input)`: 사용자 요청 처리
  - `streamRequest(input)`: 스트리밍 응답
  - `startSession()`, `endSession()`: 세션 관리

#### ToolRegistry (91줄)
- **역할**: 도구 관리 시스템
- **저장 방식**: `Map<string, ToolBase>` (O(1) 검색)
- **주요 메서드**:
  - `register(tool)`: 도구 등록
  - `execute(toolCall)`: 도구 실행
  - `getDefinitions()`: LLM에 전달할 도구 정의

#### types (211줄)
- **43개 exported types**: Message, ContentBlock, ToolDefinition, LLMConfig, etc.
- **타입 카테고리**:
  - LLM 타입 (Message, ContentBlock, ToolCall)
  - 도구 타입 (ToolDefinition, ToolResult)
  - 설정 타입 (Config, LLMConfig, LLMModeConfig)
  - GUI 타입 (Coordinate, BBox, OCRAnalysis)

### 2. 브레인 시스템 (⭐ 핵심)

#### NavigationBrain (757줄)
GAI의 가장 중요한 컴포넌트입니다.

**아키텍처**:
- **NavigationGraph**: Nodes + Paths (그래프 구조)
- **ShadowDOM**: 런타임 화면 상태 (휘발성)
- **Storage**: JSON 영속성

**주요 메서드** (20+개):
- **Navigation**: `navigateTo()`, `identifyCurrentNode()`, `learnPath()`
- **Execution**: `executePath()`, `executeAction()` (private)
- **Verification**: `verifyActionResult()`
- **ShadowDOM**: `updateShadowDOM()` (private), `getShadowDOM()`
- **Graph**: `addNode()`, `getPathsFrom()`, `getAllNodes()`

#### VLMAnalyzer (268줄)
- **역할**: VLM 분석 래퍼
- **메서드**:
  - `extractProgramName()`: 프로그램명 추출
  - `identifyUIElements()`: UI 요소 분석
  - `learnNavigationPath()`: 경로 학습
  - `verifyScreenState()`: 화면 검증

#### StateHasher (103줄)
- **역할**: 상태 해싱 및 유사도 계산
- **메서드**:
  - `hashElements()`: SHA-256 해시 생성
  - `similarity()`: Jaccard 유사도 (0-1)
  - `extractKeyFeatures()`: 주요 특징 추출

#### JSONStorage (256줄)
- **역할**: 네비게이션 그래프 영속화
- **파일 경로**: `data/brain/navigation.json`
- **Serialization**: Map → Array, Date → ISO string
- **Deserialization**: Array → Map, ISO string → Date

### 3. LLM 시스템

#### LLMManager (181줄)
- **역할**: 멀티모드 LLM 관리
- **모드 시스템**: default, fast, vision
- **Provider Factory**: `createLLM(config)` → BaseLLM

#### 4개 제공자
| 제공자 | 라인 수 | 도구 호출 | SDK |
|--------|---------|-----------|-----|
| **AnthropicLLM** | 283 | ✅ | @anthropic-ai/sdk |
| **OpenAILLM** | 288 | ✅ | openai |
| **GoogleLLM** | 246 | ❌ | @google/generative-ai |
| **OllamaLLM** | 233 | ❌ | HTTP (no SDK) |

### 4. 도구 시스템

#### ToolBase (56줄)
모든 도구의 추상 클래스:
```typescript
abstract class ToolBase {
  abstract name: string;
  abstract description: string;
  abstract inputSchema: object;
  abstract execute(input): Promise<ToolResult>;
}
```

#### Vision Tools (4개)
1. **SmartScreenReaderTool** (170줄) - quick/detailed 모드
2. **ScreenCaptureTool** - 화면 캡처
3. **OCRTool** - OCR 분석
4. **ScreenReaderTool** - 레거시

#### Action Tools (5개)
1. **ClickTool** (166줄) - 좌표/텍스트 기반 클릭
2. **TypeTool** (86줄) - 텍스트 입력
3. **KeyPressTool** (89줄) - 키보드 입력
4. **TabNavigateTool** (81줄) - Tab 탐색
5. **SpotlightTool** (96줄) - Spotlight 실행

#### Brain Tools (3개)
1. **NavigateToTool** (85줄) - 네비게이션
2. **GetCurrentNodeTool** (82줄) - 현재 노드 조회
3. **LaunchAppTool** (106줄) - 앱 실행

### 5. 설정 시스템

#### ConfigLoader (300줄)
**3계층 로딩**:
```
1. 기본값 (코드 내부)
   ↓
2. JSON 파일 (config/config.json)
   ↓
3. 환경변수 (.env) ← 최우선
```

**검증**:
- API 키 필수 확인 (ollama 제외)
- 모델명 검증
- Config 타입 검증

### 6. 유틸리티

#### Automation
- **MouseController** (118줄): nut.js 기반 마우스 제어
- **KeyboardController** (193줄): nut.js 기반 키보드 제어
- **CoordinateConverter** (68줄): Pixel ↔ Normalized 변환

#### OCR
- **MacOCRProvider** (80줄): macOS Vision Framework
- **OCRFactory** (42줄): 플랫폼별 OCR 제공자 생성

#### Permissions
- **MacPermissions** (60줄): Accessibility, Screen Recording 권한

---

## 실행 흐름

### 전체 흐름 요약

```
사용자 입력: "계산기를 열고 2+2를 계산해줘"
    ↓
[초기화 단계]
1. macOS 권한 확인 (Accessibility, Screen Recording)
2. 설정 로드 (config.json + .env)
3. LLMManager 초기화 (3개 모드 설정)
4. Agent + ToolRegistry 초기화
5. NavigationBrain 초기화 (JSON에서 그래프 로드)
6. 12개 도구 등록
    ↓
[에이전트 루프 - 반복 1]
7. LLMManager.send(tools) → "launch_app({ appName: 'Calculator' })"
8. ToolRegistry.execute() → LaunchAppTool
9. 결과 → LLMManager.addToolResult()
    ↓
[반복 2]
10. LLMManager.send() → "type_text({ text: '2+2' })" + "press_key({ key: 'enter' })"
11. 도구 실행 (TypeTool, KeyPressTool)
12. 결과 → LLM
    ↓
[반복 3]
13. LLMManager.send() → 도구 호출 없음
14. 최종 응답: "결과는 4입니다"
    ↓
[정리 단계]
15. agent.endSession()
16. 결과 출력
```

### 초기화 시퀀스 (상세)

```typescript
// 1. 권한 확인
if (isMacOS()) {
  const permissions = await MacPermissions.checkAllPermissions();
  if (!permissions.allGranted) {
    await MacPermissions.requestAccessibility();
    await MacPermissions.requestScreenRecording();
    process.exit(1);
  }
}

// 2. 설정 로드
const configLoader = new ConfigLoader();
const config = configLoader.get();
const validation = configLoader.validate();
if (!validation.valid) {
  console.error(validation.errors);
  process.exit(1);
}

// 3. LLM 초기화
const llmManager = new LLMManager(config.llm);

// 4. 도구 레지스트리 초기화
const toolRegistry = new ToolRegistry();

// 5. 도구 등록 (12개)
toolRegistry.register(new EchoTool());
toolRegistry.register(new SmartScreenReaderTool(llmManager));
toolRegistry.register(new ScreenCaptureTool());
// ... (나머지 도구)

// 6. 네비게이션 브레인 초기화
const storage = new JSONStorage();
const brain = new NavigationBrain(storage, llmManager);
await brain.initialize(); // JSON 로드 + Spotlight 노드 초기화

// 7. 브레인 도구 등록
toolRegistry.register(new NavigateToTool(brain));
toolRegistry.register(new GetCurrentNodeTool(brain));
toolRegistry.register(new LaunchAppTool());

// 8. 에이전트 초기화
const agent = new Agent(llmManager, toolRegistry, {
  maxIterations: config.agent.maxIterations
});
agent.startSession();

// 9. 요청 처리
const response = await agent.processRequest(userInput);

// 10. 출력 및 정리
console.log(response.message);
agent.endSession();
```

### 에이전트 루프 (상세)

```typescript
// Agent.processRequest() 내부
async processRequest(input: string): Promise<AgentResponse> {
  // 1. 사용자 메시지 추가
  this.llmManager.addUserMessage(input);

  let iteration = 0;
  const maxIterations = this.config.maxIterations; // 10

  // 2. 에이전트 루프
  while (iteration < maxIterations) {
    iteration++;

    // 3. LLM 호출 (도구 정의 포함)
    const response = await this.llmManager.send(
      this.toolRegistry.getDefinitions()
    );

    // 4. 도구 호출 확인
    if (response.toolCalls && response.toolCalls.length > 0) {
      // 5. 도구 실행 (병렬)
      const results = await this.executeToolCalls(response.toolCalls);

      // 6. 결과를 LLM에 전달
      for (const result of results) {
        this.llmManager.addToolResult(result.toolCallId, result);
      }

      // 7. 다음 반복으로 계속
      continue;
    }

    // 8. 도구 호출 없으면 최종 응답 반환
    return {
      success: true,
      message: response.content,
      iterations: iteration
    };
  }

  // 9. 최대 반복 도달
  return {
    success: false,
    message: "최대 반복 횟수에 도달했습니다",
    iterations: maxIterations
  };
}
```

---

## 문서 구조

본 프로젝트는 **10개 문서**로 체계화되어 있습니다:

| 번호 | 파일명 | 내용 | 중요도 |
|------|--------|------|--------|
| 00 | **00-개요.md** (본 문서) | 프로젝트 전체 개요 | ⭐⭐⭐ |
| 01 | **01-아키텍처.md** | 아키텍처 설계 및 패턴 | ⭐⭐⭐ |
| 02 | **02-코어시스템.md** | Agent, ToolRegistry, types | ⭐⭐⭐ |
| 03 | **03-브레인시스템.md** | NavigationBrain (가장 중요) | ⭐⭐⭐⭐⭐ |
| 04 | **04-LLM시스템.md** | LLMManager + 4개 제공자 | ⭐⭐⭐ |
| 05 | **05-도구시스템.md** | 12개 도구 상세 | ⭐⭐⭐ |
| 06 | **06-설정시스템.md** | ConfigLoader | ⭐⭐ |
| 07 | **07-유틸리티.md** | Automation, OCR, Permissions | ⭐⭐ |
| 08 | **08-초기화.md** | 진입점 및 초기화 시퀀스 | ⭐⭐ |
| 09 | **09-데이터흐름.md** | 데이터 흐름 및 상호작용 | ⭐⭐⭐ |

**추천 읽기 순서**:
1. 00-개요.md (본 문서) - 전체 이해
2. 03-브레인시스템.md - 핵심 메커니즘
3. 02-코어시스템.md - 에이전트 루프
4. 05-도구시스템.md - 도구 사용법
5. 04-LLM시스템.md - LLM 설정

---

## 핵심 통찰

### 1. 노드 vs 섀도우DOM

| 구분 | 노드 (Node) | 섀도우DOM (ShadowDOM) |
|------|-------------|------------------------|
| **개념** | 정적인 "장소" | 런타임 스냅샷 |
| **식별** | programName + stateHash | nodeId + instanceHash |
| **저장** | JSON 파일 (영구) | 메모리 (휘발성) |
| **목적** | 네비게이션 그래프의 정점 | 현재 화면 상태 추적 |
| **예시** | `{ programName: "Chrome", stateHash: "abc123" }` | `{ screenshot, uiElements, ocrResult }` |

**핵심**:
- **노드**: "어디"를 나타냄 (장소)
- **섀도우DOM**: "무엇"을 나타냄 (상태)

### 2. 모드 시스템

| 모드 | Ollama 모델 예시 | 용도 | 사용 시점 |
|------|-----------------|------|-----------|
| **Vision** | qwen2.5vl:32b | 화면 분석 | 경로 학습, UI 분석 |
| **Default** | gpt-oss:120b | 에이전트 루프 | 일반 작업, 도구 호출 |
| **Fast** | gpt-oss:20b | 빠른 작업 | 간단한 텍스트 처리 |

**최적화 전략**:
1. Vision mode는 경로 학습 시에만 사용 (한 번)
2. Default mode로 에이전트 루프 실행
3. Fast mode로 간단한 텍스트 작업 처리
4. 경로 재사용 시 VLM 호출 최소화

**예시**:
```
첫 방문: Vision mode → 경로 학습 → JSON 저장
재방문: VLM 호출 최소화 → JSON에서 로드 → 실행
→ 성능 향상!
```

### 3. OCR + VLM 시너지

| 기술 | 장점 | 단점 |
|------|------|------|
| **OCR** | 정확한 텍스트, BBox 좌표, 빠름 | 버튼/아이콘 인식 불가 |
| **VLM** | 시각적 이해, 버튼 인식, 맥락 파악 | 느림, 텍스트 부정확 |

**하이브리드 전략**:
1. OCR로 텍스트 추출 (빠르고 정확)
2. OCR 결과를 VLM에 컨텍스트로 제공
3. VLM이 시각적 요소와 텍스트 결합 분석
4. VLM 토큰 사용 최소화 (텍스트는 OCR로 이미 제공)

**결과**:
- 정확도 ↑ (OCR + VLM)
- 효율성 ↑ (VLM 토큰 절감)
- 속도 ↑ (OCR이 빠름)

### 4. 그래프 재사용

한 번 학습한 경로는 JSON에 저장되어 다음번에 VLM 호출 없이 재사용됩니다.

**그래프 구조**:
```json
{
  "nodes": [
    {
      "id": { "programName": "Finder", "stateHash": "abc123" },
      "metadata": { "title": "Desktop", "createdAt": "..." }
    },
    {
      "id": { "programName": "Finder", "stateHash": "def456" },
      "metadata": { "title": "Documents", "createdAt": "..." }
    }
  ],
  "paths": [
    {
      "id": "path-1",
      "fromNodeId": { "programName": "Finder", "stateHash": "abc123" },
      "toNodeId": { "programName": "Finder", "stateHash": "def456" },
      "actions": [
        { "type": "click", "data": { "text": "Documents" } },
        { "type": "wait", "data": { "ms": 500 } }
      ],
      "metadata": { "successRate": 1.0, "usageCount": 5 }
    }
  ]
}
```

**재사용 효과**:
- 비용: $0.15 → $0.00 (100% 절감)
- 시간: 5초 → 2초 (150% 빠름)
- 정확도: VLM 변동성 제거

---

## 확장 가능성

### 1. Windows OCR 제공자

```typescript
// src/utils/ocr/WindowsOCRProvider.ts
export class WindowsOCRProvider implements OCRProvider {
  async analyze(imagePath: string): Promise<OCRAnalysis> {
    // Windows.Media.Ocr API 사용
  }
}
```

### 2. 새로운 LLM 제공자 (Grok 등)

```typescript
// src/llm/providers/GrokLLM.ts
export class GrokLLM extends BaseLLM {
  async send(tools?: ToolDefinition[]): Promise<LLMResponse> {
    // Grok API 호출
  }
}
```

### 3. 새로운 도구 (Scroll, Drag 등)

```typescript
// src/tools/gui/action/ScrollTool.ts
export class ScrollTool extends ToolBase {
  name = 'scroll';
  description = '화면 스크롤';

  async execute(input: { amount: number; direction: 'up' | 'down' }) {
    // 스크롤 구현
  }
}
```

### 4. 스토리지 백엔드 (PostgreSQL, MongoDB)

```typescript
// src/brain/storage/PostgreSQLStorage.ts
export class PostgreSQLStorage implements BrainStorage {
  async load(): Promise<SerializableNavigationGraph | null> {
    // PostgreSQL에서 로드
  }

  async save(graph: SerializableNavigationGraph): Promise<void> {
    // PostgreSQL에 저장
  }
}
```

### 5. 경로 최적화 (A* 알고리즘)

현재는 직접 경로만 학습하지만, A* 알고리즘을 사용하면 최적 경로를 자동으로 찾을 수 있습니다:

```
A → B → C 경로가 있을 때
A → C로 직접 가는 경로가 없으면
A → B → C를 연결하여 자동 실행
```

---

## 다음 단계

각 시스템의 상세 내용은 개별 문서를 참고하세요:
- [01-아키텍처.md](01-아키텍처.md) - 아키텍처 설계
- [02-코어시스템.md](02-코어시스템.md) - Agent, ToolRegistry
- [03-브레인시스템.md](03-브레인시스템.md) ⭐ - NavigationBrain (가장 중요)
- [04-LLM시스템.md](04-LLM시스템.md) - LLMManager
- [05-도구시스템.md](05-도구시스템.md) - 12개 도구
- [06-설정시스템.md](06-설정시스템.md) - ConfigLoader
- [07-유틸리티.md](07-유틸리티.md) - Automation, OCR
- [08-초기화.md](08-초기화.md) - 진입점
- [09-데이터흐름.md](09-데이터흐름.md) - 데이터 흐름

---

이 문서는 GAI 프로젝트의 전체 개요를 제공합니다. 각 시스템의 상세 내용은 개별 문서를 참고하세요.
