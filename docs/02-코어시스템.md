# 코어 시스템

## 목차

1. [개요](#개요)
2. [Agent (에이전트)](#agent-에이전트)
3. [ToolRegistry (도구 레지스트리)](#toolregistry-도구-레지스트리)
4. [types (타입 시스템)](#types-타입-시스템)
5. [사용 예시](#사용-예시)

---

## 개요

코어 시스템은 GAI의 핵심 오케스트레이션 계층으로, 3개의 파일로 구성됩니다:

| 파일 | 라인 수 | 역할 |
|------|---------|------|
| **Agent.ts** | 156 | 에이전트 루프 오케스트레이터 |
| **ToolRegistry.ts** | 91 | 도구 관리 시스템 |
| **types.ts** | 211 | 타입 정의 (43개 exported types) |

### 책임

1. **Agent**: 사용자 요청을 받아 LLM과 도구를 반복적으로 호출하며 작업 수행
2. **ToolRegistry**: 도구 등록, 검색, 실행 관리
3. **types**: 전체 시스템의 타입 안전성 보장

---

## Agent (에이전트)

**파일**: `src/core/Agent.ts` (156줄)

### 목적

Agent는 **에이전트 루프 오케스트레이터**입니다. 사용자의 요청을 받아 LLM에 전달하고, LLM이 도구를 호출하면 실행한 후 결과를 다시 LLM에 전달하는 과정을 반복합니다.

### 클래스 구조

```typescript
export class Agent {
  private maxIterations: number;
  private verbose: boolean;

  constructor(
    private llmManager: LLMManager,     // DI: LLM 관리자
    private toolRegistry: ToolRegistry, // DI: 도구 레지스트리
    config: AgentConfig = {}
  )
}

export interface AgentConfig {
  maxIterations?: number;  // 기본값: 10
  verbose?: boolean;       // 기본값: false
}
```

### Public API

#### 1. processRequest(input: string): Promise<AgentResponse>

사용자 요청을 처리하는 핵심 메서드입니다.

**시그니처**:
```typescript
async processRequest(input: string): Promise<AgentResponse>
```

**파라미터**:
- `input: string` - 사용자 요청 (예: "계산기를 열고 2+2를 계산해줘")

**반환값**:
```typescript
interface AgentResponse {
  message: string;          // 최종 응답 메시지
  toolCalls?: ToolCall[];   // 실행된 도구 호출 목록
  finished: boolean;        // 작업 완료 여부
}
```

**내부 로직** (단계별):

```typescript
async processRequest(input: string): Promise<AgentResponse> {
  // 1. 사용자 메시지를 LLM 히스토리에 추가
  this.llmManager.addUserMessage(input);

  let iterations = 0;
  let lastResponse: AgentResponse = {
    message: '',
    finished: false,
  };

  // 2. 에이전트 루프 (최대 10회 반복)
  while (iterations < this.maxIterations) {
    iterations++;

    // 3. LLM에 요청 전송 (도구 정의 포함)
    const tools = this.toolRegistry.getDefinitions();
    const response = await this.llmManager.send(tools);

    // 4. 도구 호출 확인
    if (!response.toolCalls || response.toolCalls.length === 0) {
      // 도구 호출 없음 → 최종 응답
      lastResponse = {
        message: response.content,
        finished: true,
      };
      break;
    }

    // 5. 도구 호출 실행 (병렬)
    const toolResults = await this.executeToolCalls(response.toolCalls);

    // 6. 도구 결과를 LLM 히스토리에 추가
    for (let i = 0; i < response.toolCalls.length; i++) {
      const toolCall = response.toolCalls[i];
      const result = toolResults[i];

      if (result.success) {
        this.llmManager.addToolResult(toolCall.id, result.data);
      } else {
        this.llmManager.addToolResult(toolCall.id, result.error);
      }
    }

    // 7. 다음 반복으로 계속
    lastResponse = {
      message: response.content,
      toolCalls: response.toolCalls,
      finished: false,
    };
  }

  // 8. 최대 반복 도달 시
  if (iterations >= this.maxIterations) {
    lastResponse.message += '\n\n[Max iterations reached]';
    lastResponse.finished = true;
  }

  return lastResponse;
}
```

**실행 흐름 다이어그램**:

```
processRequest("계산기를 열고 2+2를 계산해줘")
    ↓
addUserMessage("계산기를 열고 2+2를 계산해줘")
    ↓
┌─────────────────────────────────────────────┐
│  While Loop (iteration < 10)                │
│                                             │
│  [Iteration 1]                              │
│  llmManager.send(tools)                     │
│      → response.toolCalls = [               │
│           { name: "launch_app",             │
│             input: { appName: "Calculator"} │
│           }                                 │
│        ]                                    │
│  executeToolCalls()                         │
│      → LaunchAppTool.execute()              │
│      → result: { success: true }            │
│  addToolResult(toolCallId, result)          │
│                                             │
│  [Iteration 2]                              │
│  llmManager.send(tools)                     │
│      → response.toolCalls = [               │
│           { name: "type_text",              │
│             input: { text: "2+2" }          │
│           },                                │
│           { name: "press_key",              │
│             input: { key: "enter" }         │
│           }                                 │
│        ]                                    │
│  executeToolCalls()                         │
│      → TypeTool.execute()                   │
│      → KeyPressTool.execute()               │
│  addToolResult(...)                         │
│                                             │
│  [Iteration 3]                              │
│  llmManager.send(tools)                     │
│      → response.toolCalls = null            │
│      → response.content = "결과는 4입니다"   │
│  Break! (도구 호출 없음)                     │
│                                             │
└─────────────────────────────────────────────┘
    ↓
Return {
  message: "결과는 4입니다",
  finished: true
}
```

#### 2. streamRequest(input: string): AsyncIterableIterator<string>

스트리밍 응답을 위한 메서드입니다.

**시그니처**:
```typescript
async *streamRequest(input: string): AsyncIterableIterator<string>
```

**사용법**:
```typescript
for await (const chunk of agent.streamRequest("화면을 분석해줘")) {
  process.stdout.write(chunk);
}
```

**내부 로직**:
```typescript
async *streamRequest(input: string): AsyncIterableIterator<string> {
  this.llmManager.addUserMessage(input);
  const tools = this.toolRegistry.getDefinitions();

  for await (const chunk of this.llmManager.stream(tools)) {
    if (chunk.type === 'content' && chunk.content) {
      yield chunk.content;              // 텍스트 청크
    } else if (chunk.type === 'tool_use' && chunk.toolCall) {
      yield `\n[Tool: ${chunk.toolCall.name}]`;  // 도구 호출 알림
    }
  }
}
```

**주의**: 현재 구현은 도구 실행을 포함하지 않으며, 텍스트 스트리밍만 지원합니다.

#### 3. startSession(): void

새로운 세션을 시작합니다 (히스토리 초기화).

```typescript
startSession(): void {
  this.llmManager.clearHistory();
}
```

#### 4. endSession(): void

세션을 종료합니다 (히스토리 초기화).

```typescript
endSession(): void {
  this.llmManager.clearHistory();
}
```

### Private Methods

#### executeToolCalls(toolCalls: ToolCall[]): Promise<ToolResult[]>

여러 도구 호출을 **병렬로** 실행합니다.

```typescript
private async executeToolCalls(toolCalls: ToolCall[]): Promise<ToolResult[]> {
  if (this.verbose) {
    console.log(`\nExecuting ${toolCalls.length} tool calls...`);
  }

  // Promise.all을 사용하여 병렬 실행
  const results = await Promise.all(
    toolCalls.map(async (toolCall) => {
      if (this.verbose) {
        console.log(`  - ${toolCall.name}(...)`);
      }

      const result = await this.toolRegistry.execute(toolCall);

      if (this.verbose) {
        console.log(`    → ${result.success ? 'Success' : 'Failed'}`);
      }

      return result;
    })
  );

  return results;
}
```

**병렬 실행의 장점**:
- 여러 도구를 동시에 실행하여 시간 절약
- 예: `type_text`와 `press_key`를 순차적으로 실행하는 것이 아니라 동시에 실행 (실제로는 순차적으로 실행되지만, I/O 대기 시간 최소화)

**주의**: 실제로는 대부분의 도구가 순차적으로 실행되어야 하므로, LLM이 적절한 순서로 도구를 호출해야 합니다.

### Verbose 모드

`verbose: true`로 설정하면 상세한 로그를 출력합니다:

```
[Iteration 1/10]
LLM Response: I'll help you open the calculator and perform...
Stop Reason: tool_use
Tool Calls: 1

Executing 1 tool calls...
  - launch_app({"appName":"Calculator"}...)
    → Success

[Iteration 2/10]
LLM Response: Now I'll type the calculation...
Stop Reason: tool_use
Tool Calls: 2

Executing 2 tool calls...
  - type_text({"text":"2+2"}...)
    → Success
  - press_key({"key":"enter"}...)
    → Success

[Iteration 3/10]
LLM Response: The result is 4.
Stop Reason: end_turn
Tool Calls: 0
```

---

## ToolRegistry (도구 레지스트리)

**파일**: `src/core/ToolRegistry.ts` (91줄)

### 목적

ToolRegistry는 **도구 관리 시스템**입니다. 도구를 등록하고, 검색하고, 실행하는 책임을 가집니다.

### 클래스 구조

```typescript
export class ToolRegistry {
  private tools: Map<string, ToolBase> = new Map();
}
```

**핵심 설계**:
- `Map<string, ToolBase>` 사용 → **O(1) 검색 성능**
- `ToolBase` 추상 클래스에 의존 → 모든 도구는 동일한 인터페이스

### Public API

#### 1. register(tool: ToolBase): void

도구를 등록합니다.

```typescript
register(tool: ToolBase): void {
  if (this.tools.has(tool.name)) {
    console.warn(`Tool ${tool.name} is already registered. Overwriting.`);
  }
  this.tools.set(tool.name, tool);
}
```

**사용 예시**:
```typescript
const registry = new ToolRegistry();
registry.register(new EchoTool());
registry.register(new ClickTool());
registry.register(new TypeTool());
// ... (총 12개 도구 등록)
```

**주의**: 동일한 이름의 도구를 등록하면 기존 도구를 덮어씁니다.

#### 2. execute(toolCall: ToolCall): Promise<ToolResult>

도구 호출을 실행합니다.

```typescript
async execute(toolCall: ToolCall): Promise<ToolResult> {
  const tool = this.tools.get(toolCall.name);

  if (!tool) {
    return {
      success: false,
      error: `Tool not found: ${toolCall.name}`,
    };
  }

  try {
    const result = await tool.execute(toolCall.input);
    return result;
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: `Tool execution failed: ${message}`,
    };
  }
}
```

**에러 처리**:
1. **도구가 없으면**: `{ success: false, error: "Tool not found: ..." }`
2. **도구 실행 중 예외**: `{ success: false, error: "Tool execution failed: ..." }`

**사용 예시**:
```typescript
const toolCall: ToolCall = {
  id: 'call-123',
  name: 'click',
  input: { x: 100, y: 200 }
};

const result = await registry.execute(toolCall);
// → { success: true, data: '...' }
```

#### 3. getDefinitions(): ToolDefinition[]

LLM에 전달할 도구 정의를 반환합니다.

```typescript
getDefinitions(): ToolDefinition[] {
  return Array.from(this.tools.values()).map((tool) => tool.getDefinition());
}
```

**반환값 예시**:
```typescript
[
  {
    name: 'click',
    description: '화면의 특정 위치를 클릭합니다',
    inputSchema: {
      type: 'object',
      properties: {
        x: { type: 'number', description: 'X 좌표' },
        y: { type: 'number', description: 'Y 좌표' }
      },
      required: ['x', 'y']
    }
  },
  {
    name: 'type_text',
    description: '텍스트를 입력합니다',
    inputSchema: {
      type: 'object',
      properties: {
        text: { type: 'string', description: '입력할 텍스트' }
      },
      required: ['text']
    }
  },
  // ... (총 12개)
]
```

**사용 예시**:
```typescript
const tools = registry.getDefinitions();
const response = await llmManager.send(tools);
// LLM이 도구 정의를 보고 적절한 도구를 선택
```

#### 4. get(name: string): ToolBase | undefined

이름으로 도구를 검색합니다.

```typescript
get(name: string): ToolBase | undefined {
  return this.tools.get(name);
}
```

#### 5. getAll(): ToolBase[]

모든 등록된 도구를 반환합니다.

```typescript
getAll(): ToolBase[] {
  return Array.from(this.tools.values());
}
```

#### 6. has(name: string): boolean

도구가 등록되었는지 확인합니다.

```typescript
has(name: string): boolean {
  return this.tools.has(name);
}
```

#### 7. unregister(name: string): boolean

도구를 등록 해제합니다.

```typescript
unregister(name: string): boolean {
  return this.tools.delete(name);
}
```

#### 8. clear(): void

모든 도구를 제거합니다.

```typescript
clear(): void {
  this.tools.clear();
}
```

#### 9. count(): number

등록된 도구의 개수를 반환합니다.

```typescript
count(): number {
  return this.tools.size;
}
```

---

## types (타입 시스템)

**파일**: `src/core/types.ts` (211줄)

### 43개 Exported Types

types.ts는 GAI 전체 시스템의 타입 안전성을 보장하는 **43개의 타입**을 정의합니다.

### 주요 타입 카테고리

#### 1. Message Types (메시지 시스템)

```typescript
// 메시지
export interface Message {
  role: 'user' | 'assistant';
  content: ContentBlock[];
}

// 컨텐츠 블록 (Union Type)
export type ContentBlock =
  | TextContent
  | ImageContent
  | ToolUseContent
  | ToolResultContent;

// 텍스트 컨텐츠
export interface TextContent {
  type: 'text';
  text: string;
}

// 이미지 컨텐츠
export interface ImageContent {
  type: 'image';
  source: {
    type: 'base64' | 'url';
    media_type: string;  // 'image/png', 'image/jpeg' 등
    data: string;        // base64 또는 URL
  };
}

// 도구 사용 컨텐츠
export interface ToolUseContent {
  type: 'tool_use';
  id: string;
  name: string;
  input: any;
}

// 도구 결과 컨텐츠
export interface ToolResultContent {
  type: 'tool_result';
  tool_use_id: string;
  content: string | any;
}
```

#### 2. Tool Types (도구 시스템)

```typescript
// 도구 정의 (LLM에 전달)
export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: object;  // JSON Schema
}

// 도구 호출 (LLM이 생성)
export interface ToolCall {
  id: string;
  name: string;
  input: any;
}

// 도구 실행 결과
export interface ToolResult {
  success: boolean;
  data?: any;
  error?: string;
}
```

#### 3. LLM Types (LLM 시스템)

```typescript
// LLM 응답
export interface LLMResponse {
  content: string;
  toolCalls?: ToolCall[];
  stopReason?: string;
}

// LLM 스트리밍 청크
export type LLMStreamChunk =
  | { type: 'content'; content: string }
  | { type: 'tool_use'; toolCall: ToolCall }
  | { type: 'end' };

// LLM 설정 (Union Type)
export type LLMConfig = SingleLLMConfig | LLMModeConfig;

// 단일 모드 설정
export interface SingleLLMConfig {
  provider: Provider;
  model: string;
  apiKey?: string;
  maxTokens?: number;
  temperature?: number;
}

// 멀티모드 설정
export interface LLMModeConfig {
  default: ProviderConfig;
  fast?: ProviderConfig;
  vision?: ProviderConfig;
}

// 제공자 설정
export interface ProviderConfig {
  provider: Provider;
  model: string;
  apiKey?: string;
  maxTokens?: number;
  temperature?: number;
  baseUrl?: string;  // Ollama용
}

// 제공자 타입
export type Provider = 'anthropic' | 'openai' | 'google' | 'ollama';
```

#### 4. Config Types (설정 시스템)

```typescript
// 전체 설정
export interface Config {
  llm: LLMConfig;
  telegram: TelegramConfig;
  tools: ToolsConfig;
  agent: AgentConfig;
}

// 텔레그램 설정
export interface TelegramConfig {
  enabled: boolean;
  botToken?: string;
}

// 도구 설정
export interface ToolsConfig {
  gui: boolean;
  builtin: boolean;
}

// 에이전트 설정
export interface AgentConfig {
  maxIterations?: number;
  verbose?: boolean;
}
```

#### 5. GUI Types (GUI 자동화)

```typescript
// 좌표 (Union Type)
export type Coordinate = PixelCoordinate | NormalizedCoordinate;

// 픽셀 좌표
export interface PixelCoordinate {
  x: number;  // 0 ~ screenWidth
  y: number;  // 0 ~ screenHeight
}

// 정규화 좌표 (0.0 ~ 1.0)
export interface NormalizedCoordinate {
  x: number;  // 0.0 ~ 1.0
  y: number;  // 0.0 ~ 1.0
}

// Bounding Box
export interface BBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

// OCR 분석 결과
export interface OCRAnalysis {
  fullText: string;
  elements: OCRElement[];
}

// OCR 요소
export interface OCRElement {
  text: string;
  confidence: number;  // 0.0 ~ 1.0
  bbox: BBox;
}
```

#### 6. Agent Types (에이전트)

```typescript
// 에이전트 응답
export interface AgentResponse {
  message: string;
  toolCalls?: ToolCall[];
  finished: boolean;
}
```

---

## 사용 예시

### 기본 사용

```typescript
import { Agent } from './core/Agent';
import { ToolRegistry } from './core/ToolRegistry';
import { LLMManager } from './llm/LLMManager';
import { EchoTool } from './tools/gui/EchoTool';
import { ClickTool } from './tools/gui/action/ClickTool';

// 1. LLM 초기화
const llmManager = new LLMManager({
  default: {
    provider: 'anthropic',
    model: 'claude-sonnet-4-5-20250929',
    apiKey: process.env.ANTHROPIC_API_KEY!
  }
});

// 2. 도구 레지스트리 초기화
const toolRegistry = new ToolRegistry();
toolRegistry.register(new EchoTool());
toolRegistry.register(new ClickTool());

// 3. 에이전트 초기화
const agent = new Agent(llmManager, toolRegistry, {
  maxIterations: 10,
  verbose: true
});

// 4. 세션 시작
agent.startSession();

// 5. 요청 처리
const response = await agent.processRequest("Echo 'Hello World'");
console.log(response.message);

// 6. 세션 종료
agent.endSession();
```

### 스트리밍 사용

```typescript
// 스트리밍 응답
for await (const chunk of agent.streamRequest("화면을 분석해줘")) {
  process.stdout.write(chunk);
}
```

### 도구 레지스트리 사용

```typescript
const registry = new ToolRegistry();

// 도구 등록
registry.register(new EchoTool());
registry.register(new ClickTool());
registry.register(new TypeTool());

// 도구 개수 확인
console.log(`Registered tools: ${registry.count()}`);
// → Registered tools: 3

// 도구 존재 확인
console.log(registry.has('click'));  // → true
console.log(registry.has('scroll')); // → false

// 도구 가져오기
const clickTool = registry.get('click');
if (clickTool) {
  console.log(clickTool.description);
}

// 모든 도구 가져오기
const allTools = registry.getAll();
console.log(allTools.map(tool => tool.name));
// → ['echo', 'click', 'type_text']

// 도구 정의 가져오기 (LLM용)
const definitions = registry.getDefinitions();
console.log(definitions);
// → [{ name: 'echo', description: '...', inputSchema: {...} }, ...]
```

### 에이전트 루프 시뮬레이션

```typescript
// 1회 반복 예시
const response1 = await llmManager.send(toolRegistry.getDefinitions());
// response1.toolCalls = [{ name: 'click', input: { x: 100, y: 200 } }]

const result = await toolRegistry.execute(response1.toolCalls[0]);
// result = { success: true, data: '...' }

llmManager.addToolResult(response1.toolCalls[0].id, result.data);

// 2회 반복
const response2 = await llmManager.send(toolRegistry.getDefinitions());
// response2.toolCalls = null
// response2.content = "클릭했습니다"
```

---

## 요약

### Agent
- **역할**: 에이전트 루프 오케스트레이터
- **최대 반복**: 10회 (설정 가능)
- **병렬 실행**: 도구 호출을 병렬로 처리
- **세션 관리**: startSession(), endSession()

### ToolRegistry
- **역할**: 도구 관리 시스템
- **저장 방식**: Map<string, ToolBase> (O(1) 검색)
- **주요 메서드**: register(), execute(), getDefinitions()

### types
- **역할**: 타입 안전성 보장
- **타입 개수**: 43개 exported types
- **카테고리**: Message, Tool, LLM, Config, GUI, Agent

코어 시스템은 GAI의 **오케스트레이션 계층**으로, LLM과 도구를 연결하는 핵심 역할을 수행합니다.

---

다음 문서: [03-브레인시스템.md](03-브레인시스템.md) (가장 중요!)
