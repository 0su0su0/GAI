# 5. 도구 시스템 (Tools System)

## 목차
1. [ToolBase - 추상 클래스](#1-toolbase---추상-클래스)
2. [Vision Tools - 화면 분석 도구](#2-vision-tools---화면-분석-도구)
3. [Action Tools - GUI 조작 도구](#3-action-tools---gui-조작-도구)
4. [Brain Tools - 네비게이션 도구](#4-brain-tools---네비게이션-도구)
5. [테스트 도구](#5-테스트-도구)
6. [도구 등록 및 실행 흐름](#6-도구-등록-및-실행-흐름)

---

## 개요

GAI의 도구 시스템은 **LLM이 GUI를 인식하고 조작할 수 있게 해주는 핵심 인터페이스**입니다. 모든 도구는 `ToolBase` 추상 클래스를 상속받아 구현되며, LLM은 도구의 정의(definition)를 받아 적절한 도구를 선택하고 실행합니다.

**도구 분류**:
- **Vision Tools (4개)**: 화면 캡처, OCR, LLM 기반 분석
- **Action Tools (5개)**: 클릭, 타이핑, 키보드 단축키, Tab 네비게이션, Spotlight
- **Brain Tools (3개)**: 네비게이션, 현재 노드 정보, 앱 실행
- **Misc (1개)**: Echo (테스트용)

**총 13개 도구** (실제 12개 + deprecated 1개)

---

## 1. ToolBase - 추상 클래스

### 파일 위치
- `src/tools/ToolBase.ts` (56 lines)

### 목적
모든 도구의 기반 클래스로, 도구의 정의, 검증, 실행 인터페이스를 표준화합니다.

### 추상 속성/메서드

```typescript
export abstract class ToolBase {
  protected llm?: BaseLLM;

  constructor(llm?: BaseLLM) {
    this.llm = llm;
  }

  // 각 도구가 반드시 정의해야 하는 속성
  abstract readonly name: string;
  abstract readonly description: string;
  abstract readonly inputSchema: object;

  // 각 도구가 반드시 구현해야 하는 메서드
  abstract execute(input: ToolInput): Promise<ToolResult>;
}
```

**필수 구현 사항**:
- `name`: 도구 이름 (예: `'click'`, `'type_text'`)
- `description`: LLM이 이해할 수 있는 도구 설명
- `inputSchema`: JSON Schema 형식의 입력 파라미터 정의
- `execute()`: 실제 도구 실행 로직

### 공통 메서드

#### 1) `getDefinition(): ToolDefinition`

**목적**: LLM에게 전달할 도구 정의 생성

**내부 로직**:
```typescript
getDefinition(): ToolDefinition {
  return {
    name: this.name,
    description: this.description,
    input_schema: this.inputSchema,
  };
}
```

**출력 예시**:
```json
{
  "name": "click",
  "description": "Click at specific coordinates or search for text...",
  "input_schema": {
    "type": "object",
    "properties": { "x": {...}, "y": {...} },
    "required": []
  }
}
```

#### 2) `validateInput(input: ToolInput): void`

**목적**: 입력 파라미터 검증 (required 필드 체크)

**내부 로직**:
```typescript
protected validateInput(input: ToolInput): void {
  // 1. 입력이 객체인지 확인
  if (!input || typeof input !== 'object') {
    throw new Error(`Invalid input for tool ${this.name}: expected object`);
  }

  // 2. required 필드 체크
  const schema = this.inputSchema as { required?: string[] };
  const requiredFields = schema.required;
  if (requiredFields) {
    for (const field of requiredFields) {
      if (!(field in input)) {
        throw new Error(`Missing required field '${field}' for tool ${this.name}`);
      }
    }
  }
}
```

**검증 내용**:
- Input이 object 타입인지 확인
- `inputSchema.required`에 정의된 필드가 모두 존재하는지 확인
- 없으면 Error throw

#### 3) `hasLLM(): boolean`

**목적**: 도구가 LLM 인스턴스를 가지고 있는지 확인

```typescript
protected hasLLM(): boolean {
  return this.llm !== undefined;
}
```

**사용 사례**:
- SmartScreenReaderTool: LLM 없이는 실행 불가
- ClickTool, TypeTool 등: LLM 불필요 (자체 로직만 사용)

### 의존성
- `core/types.ts`: ToolDefinition, ToolResult, ToolInput
- `llm/base/BaseLLM.ts`: BaseLLM (선택적)

---

## 2. Vision Tools - 화면 분석 도구

Vision Tools는 화면을 캡처하고 분석하는 도구들입니다. OCR, Vision LLM을 활용하여 GUI 요소를 인식합니다.

### 2.1 ScreenCaptureTool

**파일**: `src/tools/gui/vision/ScreenCaptureTool.ts` (89 lines)

#### 목적
화면 전체 또는 특정 영역을 캡처하여 base64 인코딩된 이미지로 반환합니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    region: {
      type: 'object',
      properties: {
        x: { type: 'number', description: 'X coordinate of the top-left corner' },
        y: { type: 'number', description: 'Y coordinate of the top-left corner' },
        width: { type: 'number', description: 'Width of the region' },
        height: { type: 'number', description: 'Height of the region' },
      },
      description: 'Region to capture. If not provided, captures the entire screen.',
    },
    format: {
      type: 'string',
      enum: ['png', 'jpeg'],
      description: 'Image format',
      default: 'png',
    },
  },
};
```

**파라미터**:
- `region` (선택): 캡처할 영역 (미제공 시 전체 화면)
- `format` (선택): 이미지 포맷 (기본값: 'png')

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  // 1. 입력 검증
  this.validateInput(input);

  // 2. 화면 크기 가져오기
  const screenSize = robot.getScreenSize(); // robotjs 사용

  // 3. 캡처 영역 결정
  const region = typedInput.region || {
    x: 0, y: 0,
    width: screenSize.width,
    height: screenSize.height,
  };

  // 4. 화면 캡처 (robotjs)
  const screenshot = robot.screen.capture(
    region.x, region.y,
    region.width, region.height
  );

  // 5. Buffer → base64 변환
  const imageBuffer = screenshot.image;
  const base64 = imageBuffer.toString('base64');

  // 6. 결과 반환
  const result: ScreenCaptureResult = {
    base64,
    width: screenshot.width,
    height: screenshot.height,
    timestamp: new Date().toISOString(),
    format: typedInput.format || 'png',
  };

  return {
    success: true,
    data: JSON.stringify(result),
  };
}
```

**단계별 설명**:
1. **입력 검증**: validateInput() 호출
2. **화면 크기**: `robot.getScreenSize()` → `{width, height}`
3. **영역 결정**: region 파라미터 없으면 전체 화면
4. **캡처 실행**: `robot.screen.capture()` → Bitmap 객체
5. **Base64 변환**: Buffer → string (base64)
6. **결과 반환**: ScreenCaptureResult JSON

#### 의존성
- `robotjs`: 화면 캡처 (C++ native addon)
- `core/types.ts`: CaptureScreenInput, ScreenCaptureResult

#### 사용 예시

```typescript
// 전체 화면 캡처
const result1 = await screenCaptureTool.execute({});

// 특정 영역 캡처 (100x100 ~ 500x500)
const result2 = await screenCaptureTool.execute({
  region: { x: 100, y: 100, width: 400, height: 400 },
  format: 'jpeg',
});
```

---

### 2.2 OCRTool

**파일**: `src/tools/gui/vision/OCRTool.ts` (107 lines)

#### 목적
이미지 파일 또는 현재 화면에서 OCR을 수행하여 텍스트와 위치(bounding box)를 추출합니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    imagePath: {
      type: 'string',
      description: 'Path to the image file to analyze',
    },
    captureScreen: {
      type: 'boolean',
      description: 'If true, captures the current screen and performs OCR on it',
      default: false,
    },
  },
};
```

**파라미터**:
- `imagePath` (선택): 분석할 이미지 경로
- `captureScreen` (선택): true면 화면 캡처 후 OCR

**둘 중 하나는 필수**

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  // 1. OCR 지원 여부 확인 (macOS/Windows만)
  if (!OCRFactory.isSupported()) {
    return { success: false, error: 'OCR is not supported on this platform.' };
  }

  // 2. OCR Provider 생성
  const ocrProvider = OCRFactory.create();
  if (!ocrProvider) {
    return { success: false, error: 'Failed to create OCR provider' };
  }

  let imagePath = typedInput.imagePath;
  let tempFile: string | null = null;

  // 3. captureScreen이 true면 화면 캡처
  if (typedInput.captureScreen) {
    const screenSize = robot.getScreenSize();
    const screenshot = robot.screen.capture(0, 0, screenSize.width, screenSize.height);

    // 임시 파일로 저장
    tempFile = join(tmpdir(), `ocr-${Date.now()}.png`);
    writeFileSync(tempFile, screenshot.image);
    imagePath = tempFile;
  }

  // 4. imagePath 필수 확인
  if (!imagePath) {
    return { success: false, error: 'Either imagePath or captureScreen must be provided' };
  }

  // 5. OCR 실행
  const result: OCRAnalysis = await ocrProvider.analyze(imagePath);

  // 6. 임시 파일 정리
  if (tempFile) {
    try {
      unlinkSync(tempFile);
    } catch (e) {
      // 무시
    }
  }

  // 7. 결과 반환
  return {
    success: true,
    data: JSON.stringify(result),
  };
}
```

**단계별 설명**:
1. **플랫폼 체크**: `OCRFactory.isSupported()` - macOS/Windows만 지원
2. **Provider 생성**: `OCRFactory.create()` → MacOCRProvider (macOS)
3. **화면 캡처 (옵션)**: `captureScreen=true`면 robotjs로 캡처 → 임시 파일 저장
4. **경로 확인**: imagePath 또는 captureScreen 중 하나 필수
5. **OCR 실행**: `ocrProvider.analyze(imagePath)` → OCRAnalysis
6. **Cleanup**: 임시 파일 삭제
7. **결과 반환**: `{ fullText, elements: [{text, confidence, bbox}] }`

#### OCRAnalysis 구조

```typescript
interface OCRAnalysis {
  fullText: string;
  elements: Array<{
    text: string;
    confidence: number;
    bbox?: BBox; // { x, y, width, height }
  }>;
}
```

#### 의존성
- `robotjs`: 화면 캡처
- `OCRFactory`: OCR Provider 생성
- `MacOCRProvider` (macOS): Vision Framework 사용
- `fs`, `path`, `os`: 임시 파일 관리

#### 사용 예시

```typescript
// 화면 캡처 후 OCR
const result1 = await ocrTool.execute({ captureScreen: true });
// → { fullText: "...", elements: [...] }

// 이미지 파일 OCR
const result2 = await ocrTool.execute({ imagePath: '/path/to/screenshot.png' });
```

---

### 2.3 SmartScreenReaderTool

**파일**: `src/tools/gui/SmartScreenReader.ts` (170 lines)

#### 목적
**LLM Mode를 활용한 화면 분석 도구**로, `quick` 모드와 `detailed` 모드를 제공합니다.
- **Quick 모드**: Fast LLM (저렴, 빠름, OCR 없음)
- **Detailed 모드**: Vision LLM + OCR (상세, 비쌈, 느림)

**중요**: 이 도구는 **LLMManager가 필수**입니다 (생성자로 주입).

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    mode: {
      type: 'string',
      enum: ['quick', 'detailed'],
      description: 'Quick mode uses fast mode, detailed mode uses vision mode',
    },
  },
  required: ['mode'],
};
```

**파라미터**:
- `mode` (필수): `'quick'` 또는 `'detailed'`

#### 생성자

```typescript
constructor(llmManager?: LLMManager) {
  super();
  this.llmManager = llmManager;
}
```

**의존성 주입**: LLMManager 인스턴스 필요

#### 실행 로직 - Quick Mode

```typescript
if (mode === 'quick') {
  // 1. 화면 캡처 (OCR 없음)
  const screenSize = robot.getScreenSize();
  const screenshot = robot.screen.capture(0, 0, screenSize.width, screenSize.height);

  // 2. Fast Mode LLM 호출 (stateless)
  const response = await this.llmManager.sendWithMode('fast', [
    {
      role: 'user',
      content: `Quickly summarize the current screen state. Screen resolution: ${width}x${height}`,
    },
  ]);

  // 3. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      timestamp: new Date().toISOString(),
      resolution: { width, height },
      mode: 'quick',
      llmMode: 'fast',
      analysis: response.content, // LLM의 텍스트 응답
    }),
  };
}
```

**특징**:
- OCR 없음 (시간/비용 절약)
- Fast LLM 사용 (Haiku 등)
- Stateless 호출 (히스토리 없음)
- 빠르고 저렴

#### 실행 로직 - Detailed Mode

```typescript
// 1. 화면 캡처
const screenshot = robot.screen.capture(0, 0, screenSize.width, screenSize.height);
const base64Image = screenshot.image.toString('base64');

// 2. OCR 실행 (플랫폼 지원 시)
let ocrData = null;
if (OCRFactory.isSupported()) {
  try {
    const ocrProvider = OCRFactory.create();
    if (ocrProvider) {
      // 임시 파일로 저장
      tempFile = join(tmpdir(), `screen-${Date.now()}.png`);
      writeFileSync(tempFile, screenshot.image);

      // OCR 실행
      const ocrResult = await ocrProvider.analyze(tempFile);
      ocrData = ocrResult;
    }
  } catch (ocrError) {
    console.warn('OCR failed, continuing with vision-only analysis:', ocrError);
  }
}

// 3. Vision LLM Prompt 준비
const promptText = ocrData
  ? `Analyze this screen in detail. I've performed OCR and found the following text elements:\n\n${JSON.stringify(ocrData.elements.slice(0, 50), null, 2)}\n\nPlease identify all clickable UI elements with their exact coordinates based on the image and OCR data.`
  : 'Analyze this screen in detail. List all UI elements, their positions, and suggest interactions.';

// 4. Vision Mode LLM 호출
const response = await this.llmManager.sendWithMode('vision', [
  {
    role: 'user',
    content: [
      {
        type: 'text',
        text: promptText,
      },
      {
        type: 'image',
        source: {
          type: 'base64',
          data: base64Image,
          media_type: 'image/png',
        },
      },
    ],
  },
]);

// 5. 임시 파일 정리
if (tempFile) {
  try {
    unlinkSync(tempFile);
  } catch (e) {}
}

// 6. 결과 반환
return {
  success: true,
  data: JSON.stringify({
    timestamp,
    resolution: { width, height },
    mode: 'detailed',
    llmMode: 'vision',
    ocrSupported: OCRFactory.isSupported(),
    ocrTextCount: ocrData?.elements.length || 0,
    analysis: response.content, // LLM의 Vision 분석 결과
  }),
};
```

**단계별 설명**:
1. **화면 캡처**: robotjs → base64 변환
2. **OCR 실행 (옵션)**: 플랫폼 지원 시 OCR → elements 추출 (최대 50개)
3. **Prompt 생성**: OCR 데이터 포함 또는 미포함
4. **Vision LLM 호출**: `sendWithMode('vision', ...)` - 이미지 + 텍스트 전송
5. **Cleanup**: 임시 파일 삭제
6. **결과 반환**: OCR 개수, Vision 분석 결과 포함

**특징**:
- OCR + Vision LLM 시너지
- Vision mode 사용 (Opus 등)
- Stateless 호출
- 상세하고 정확하지만 비쌈

#### 모드 비교

| 항목 | Quick Mode | Detailed Mode |
|------|------------|---------------|
| LLM Mode | fast | vision |
| OCR | ❌ | ✅ (플랫폼 지원 시) |
| 이미지 전송 | ❌ | ✅ (base64) |
| 속도 | 빠름 | 느림 |
| 비용 | 저렴 | 비쌈 |
| 정확도 | 낮음 | 높음 |

#### 의존성
- `robotjs`: 화면 캡처
- `LLMManager`: LLM 호출 (fast/vision mode)
- `OCRFactory`: OCR Provider (macOS/Windows)
- `fs`, `path`, `os`: 임시 파일 관리

#### 사용 예시

```typescript
// Quick mode - 빠른 요약
const result1 = await smartScreenReader.execute({ mode: 'quick' });
// → { llmMode: 'fast', analysis: "화면에 Chrome 브라우저가 열려있고..." }

// Detailed mode - 상세 분석
const result2 = await smartScreenReader.execute({ mode: 'detailed' });
// → { llmMode: 'vision', ocrTextCount: 23, analysis: "1. 버튼 'Login' at (100, 200)..." }
```

---

### 2.4 ScreenReaderTool (Deprecated)

**파일**: `src/tools/gui/ScreenReader.ts` (71 lines)

#### 상태
**Deprecated** - SmartScreenReaderTool로 대체됨

#### 설명
Placeholder 구현으로, 실제 화면 캡처나 분석은 하지 않습니다. 향후 제거 예정.

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  // Placeholder implementation
  const screenInfo = {
    timestamp: new Date().toISOString(),
    resolution: { width: 1920, height: 1080 },
    message: 'Screen capture not yet implemented. This is a placeholder.',
  };

  return {
    success: true,
    data: JSON.stringify(screenInfo),
  };
}
```

**사용 금지**: 대신 SmartScreenReaderTool 사용

---

## 3. Action Tools - GUI 조작 도구

Action Tools는 마우스, 키보드를 제어하여 실제 GUI를 조작하는 도구들입니다.

### 3.1 ClickTool

**파일**: `src/tools/gui/action/ClickTool.ts` (166 lines)

#### 목적
화면의 특정 위치를 클릭합니다. **두 가지 모드** 지원:
1. **Coordinate Mode**: 정확한 (x, y) 좌표 클릭
2. **OCR Mode**: 텍스트를 찾아서 클릭

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    x: { type: 'number', description: 'X coordinate to click' },
    y: { type: 'number', description: 'Y coordinate to click' },
    text: { type: 'string', description: 'Text to find via OCR and click on' },
    button: {
      type: 'string',
      enum: ['left', 'right', 'middle'],
      description: 'Mouse button to click',
      default: 'left',
    },
    doubleClick: {
      type: 'boolean',
      description: 'Whether to double-click',
      default: false,
    },
  },
};
```

**파라미터**:
- `x`, `y` (선택): 클릭할 좌표
- `text` (선택): OCR로 찾을 텍스트
- `button` (선택): 'left', 'right', 'middle' (기본값: 'left')
- `doubleClick` (선택): 더블클릭 여부 (기본값: false)

**제약**: `(x, y)` 또는 `text` 중 하나는 필수

#### 실행 로직 - Coordinate Mode

```typescript
// Mode 1: Click at specific coordinates
if (typedInput.x !== undefined && typedInput.y !== undefined) {
  // MouseController를 사용하여 클릭
  MouseController.clickAt(typedInput.x, typedInput.y, button, doubleClick);

  return {
    success: true,
    data: JSON.stringify({
      mode: 'coordinate',
      x: typedInput.x,
      y: typedInput.y,
      button,
      doubleClick,
    }),
  };
}
```

**특징**:
- 단순하고 빠름
- 정확한 좌표 필요
- OCR 불필요

#### 실행 로직 - OCR Mode

```typescript
// Mode 2: Find text via OCR and click
if (typedInput.text) {
  // 1. OCR 지원 확인
  if (!OCRFactory.isSupported()) {
    return { success: false, error: 'OCR is not supported on this platform...' };
  }

  // 2. OCR Provider 생성
  const ocrProvider = OCRFactory.create();
  if (!ocrProvider) {
    return { success: false, error: 'Failed to create OCR provider' };
  }

  // 3. 화면 캡처
  const screenSize = robot.getScreenSize();
  const screenshot = robot.screen.capture(0, 0, screenSize.width, screenSize.height);

  // 4. 임시 파일로 저장
  const tempFile = join(tmpdir(), `click-ocr-${Date.now()}.png`);
  writeFileSync(tempFile, screenshot.image);

  try {
    // 5. OCR 실행
    const ocrResult = await ocrProvider.analyze(tempFile);

    // 6. 텍스트 매칭 (대소문자 무시)
    const searchText = typedInput.text.toLowerCase();
    const matches = ocrResult.elements.filter((element) =>
      element.text.toLowerCase().includes(searchText)
    );

    // 7. 매칭 실패
    if (matches.length === 0) {
      return {
        success: false,
        error: `Text "${typedInput.text}" not found on screen. Found ${ocrResult.elements.length} text elements but none matched.`,
      };
    }

    // 8. 최고 신뢰도 매칭 선택
    const bestMatch = matches.sort((a, b) => b.confidence - a.confidence)[0];

    // 9. Bounding Box 확인
    if (!bestMatch.bbox) {
      return { success: false, error: 'Text found but no bounding box available' };
    }

    // 10. Bbox 중심 클릭
    MouseController.clickBBoxCenter(bestMatch.bbox, button, doubleClick);

    return {
      success: true,
      data: JSON.stringify({
        mode: 'ocr',
        text: typedInput.text,
        foundText: bestMatch.text,
        confidence: bestMatch.confidence,
        bbox: bestMatch.bbox,
        button,
        doubleClick,
      }),
    };
  } finally {
    // 11. 임시 파일 정리
    try {
      unlinkSync(tempFile);
    } catch (e) {}
  }
}
```

**단계별 설명**:
1. **OCR 지원 확인**: macOS/Windows만
2. **Provider 생성**: OCRFactory.create()
3. **화면 캡처**: robotjs
4. **임시 파일 저장**: `/tmp/click-ocr-{timestamp}.png`
5. **OCR 실행**: `ocrProvider.analyze()` → elements[]
6. **텍스트 매칭**: `element.text.toLowerCase().includes(searchText)`
7. **매칭 실패 처리**: 0개면 에러 반환
8. **최고 신뢰도 선택**: `sort((a, b) => b.confidence - a.confidence)[0]`
9. **Bbox 확인**: bbox 없으면 에러
10. **클릭 실행**: `MouseController.clickBBoxCenter(bbox)` - bbox 중심 좌표 클릭
11. **Cleanup**: 임시 파일 삭제

**OCR 매칭 로직**:
- **대소문자 무시**: `toLowerCase()` 사용
- **부분 매칭**: `includes()` - "Log"로 "Login" 매칭 가능
- **신뢰도 정렬**: OCR 신뢰도 높은 것 우선

#### 의존성
- `MouseController`: `clickAt()`, `clickBBoxCenter()`
- `OCRFactory`: OCR Provider 생성
- `robotjs`: 화면 캡처
- `fs`, `path`, `os`: 임시 파일 관리

#### 사용 예시

```typescript
// Coordinate mode - 정확한 좌표
await clickTool.execute({ x: 500, y: 300 });

// OCR mode - 텍스트 찾아서 클릭
await clickTool.execute({ text: 'Login', button: 'left' });

// Right-click + double-click
await clickTool.execute({ x: 100, y: 200, button: 'right', doubleClick: true });
```

---

### 3.2 TypeTool

**파일**: `src/tools/gui/action/TypeTool.ts` (82 lines)

#### 목적
현재 포커스된 입력 필드에 텍스트를 타이핑합니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    text: {
      type: 'string',
      description: 'Text to type',
    },
    pressEnter: {
      type: 'boolean',
      description: 'Whether to press Enter after typing',
      default: false,
    },
    delay: {
      type: 'number',
      description: 'Delay in milliseconds between each character (default: 50ms)',
      default: 50,
    },
  },
  required: ['text'],
};
```

**파라미터**:
- `text` (필수): 타이핑할 텍스트
- `pressEnter` (선택): 타이핑 후 Enter 키 누를지 여부 (기본값: false)
- `delay` (선택): 문자당 지연 시간 (기본값: 50ms)

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  // 1. text 필수 확인
  if (!typedInput.text) {
    return { success: false, error: 'text is required' };
  }

  const delay = typedInput.delay !== undefined ? typedInput.delay : 50;
  const pressEnter = typedInput.pressEnter || false;

  // 2. 텍스트 타이핑
  KeyboardController.typeText(typedInput.text, delay);

  // 3. Enter 키 누르기 (옵션)
  if (pressEnter) {
    // 100ms 지연 후 Enter
    await new Promise((resolve) => setTimeout(resolve, 100));
    KeyboardController.pressEnter();
  }

  // 4. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      text: typedInput.text,
      length: typedInput.text.length,
      pressEnter,
      delay,
    }),
  };
}
```

**단계별 설명**:
1. **필수 필드 확인**: text가 없으면 에러
2. **타이핑 실행**: `KeyboardController.typeText(text, delay)`
   - delay만큼 간격을 두고 한 글자씩 입력
3. **Enter 키 (옵션)**: pressEnter=true면 100ms 지연 후 Enter
4. **결과 반환**: 타이핑한 텍스트, 길이, 옵션 포함

**지연 시간 이유**:
- 너무 빠르면 GUI가 따라잡지 못함
- 기본 50ms는 대부분의 앱에서 안정적
- 느린 앱은 delay 증가 가능

#### 의존성
- `KeyboardController`: `typeText()`, `pressEnter()`

#### 사용 예시

```typescript
// 기본 타이핑
await typeTool.execute({ text: 'Hello World' });

// Enter 키 포함
await typeTool.execute({ text: 'username@example.com', pressEnter: true });

// 느린 타이핑 (100ms 간격)
await typeTool.execute({ text: 'slow typing', delay: 100 });
```

---

### 3.3 KeyPressTool

**파일**: `src/tools/gui/action/KeyPressTool.ts` (78 lines)

#### 목적
키보드 키를 누릅니다. **Modifier keys (Cmd, Ctrl, Alt, Shift) 지원**으로 단축키 실행 가능.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    key: {
      description: 'Key or keys to press (e.g., "c", "enter", "tab")',
      oneOf: [
        { type: 'string' },
        { type: 'array', items: { type: 'string' } }
      ],
    },
    modifiers: {
      type: 'array',
      items: {
        type: 'string',
        enum: ['command', 'ctrl', 'alt', 'shift'],
      },
      description: 'Modifier keys to hold while pressing the key',
    },
  },
  required: ['key'],
};
```

**파라미터**:
- `key` (필수): 누를 키 (문자열 또는 배열)
  - 예: `'c'`, `'enter'`, `'tab'`, `'escape'`
- `modifiers` (선택): Modifier 키 배열
  - 예: `['command']`, `['ctrl', 'shift']`

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  // 1. key 필수 확인
  if (!typedInput.key) {
    return { success: false, error: 'key is required' };
  }

  // 2. key를 배열로 변환
  const keys = Array.isArray(typedInput.key) ? typedInput.key : [typedInput.key];
  const modifiers = typedInput.modifiers || [];

  // 3. 키 조합 실행
  KeyboardController.pressKey(typedInput.key, modifiers);

  // 4. 디스플레이용 키 조합 문자열 생성
  const keyCombo = [
    ...modifiers.map((m) => m.charAt(0).toUpperCase() + m.slice(1)),
    ...keys,
  ].join('+');
  // 예: ['command', 'c'] → "Command+c"

  // 5. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      keys: typedInput.key,
      modifiers,
      combination: keyCombo,
    }),
  };
}
```

**단계별 설명**:
1. **필수 필드 확인**: key가 없으면 에러
2. **배열 변환**: 단일 key → 배열로 변환
3. **키 실행**: `KeyboardController.pressKey(key, modifiers)`
   - modifiers를 누른 상태로 key 누름
4. **키 조합 문자열**: "Command+C" 형식으로 생성
5. **결과 반환**: 실행한 키와 modifier 정보

#### Modifier Keys

| Modifier | 설명 | macOS | Windows/Linux |
|----------|------|-------|---------------|
| `command` | Command 키 | ⌘ | - |
| `ctrl` | Control 키 | ^ | Ctrl |
| `alt` | Alt/Option 키 | ⌥ | Alt |
| `shift` | Shift 키 | ⇧ | Shift |

#### 의존성
- `KeyboardController`: `pressKey()`

#### 사용 예시

```typescript
// 단순 키
await keyPressTool.execute({ key: 'enter' });

// Cmd+C (복사)
await keyPressTool.execute({ key: 'c', modifiers: ['command'] });

// Ctrl+Shift+T (탭 복원)
await keyPressTool.execute({ key: 't', modifiers: ['ctrl', 'shift'] });

// Escape
await keyPressTool.execute({ key: 'escape' });
```

**자주 사용하는 단축키**:
- `Cmd+C`: 복사
- `Cmd+V`: 붙여넣기
- `Cmd+A`: 전체 선택
- `Cmd+Tab`: 앱 전환 (macOS)
- `Alt+Tab`: 앱 전환 (Windows)

---

### 3.4 TabNavigateTool

**파일**: `src/tools/gui/action/TabNavigateTool.ts` (76 lines)

#### 목적
Tab 키를 사용하여 UI 요소 간 포커스를 이동합니다. **Forward/Backward 네비게이션** 지원.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    count: {
      type: 'number',
      description: 'Number of times to press Tab (default: 1)',
      default: 1,
    },
    reverse: {
      type: 'boolean',
      description: 'Navigate backwards using Shift+Tab (default: false)',
      default: false,
    },
  },
};
```

**파라미터**:
- `count` (선택): Tab을 누를 횟수 (기본값: 1, 최소: 1)
- `reverse` (선택): 역방향 네비게이션 (Shift+Tab) 여부 (기본값: false)

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  const count = typedInput.count !== undefined ? typedInput.count : 1;
  const reverse = typedInput.reverse || false;

  // 1. count 검증
  if (count < 1) {
    return { success: false, error: 'count must be at least 1' };
  }

  // 2. Tab을 count번 누르기
  for (let i = 0; i < count; i++) {
    KeyboardController.pressTab(reverse);

    // 3. Tab 사이 지연 (마지막 제외)
    if (i < count - 1) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }

  // 4. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      count,
      reverse,
      direction: reverse ? 'backward' : 'forward',
    }),
  };
}
```

**단계별 설명**:
1. **count 검증**: 최소 1 이상
2. **Loop**: count번 반복
   - `KeyboardController.pressTab(reverse)`
   - reverse=false → Tab
   - reverse=true → Shift+Tab
3. **지연**: 각 Tab 사이 100ms 지연 (UI 안정화)
4. **결과 반환**: count, direction 포함

**pressTab() 구현 (추정)**:
```typescript
// KeyboardController.pressTab(reverse)
if (reverse) {
  pressKey('tab', ['shift']); // Shift+Tab
} else {
  pressKey('tab', []); // Tab
}
```

#### 의존성
- `KeyboardController`: `pressTab()`

#### 사용 예시

```typescript
// 다음 요소로 이동
await tabNavigateTool.execute({ count: 1 });

// 3번 앞으로 이동
await tabNavigateTool.execute({ count: 3 });

// 2번 뒤로 이동 (Shift+Tab)
await tabNavigateTool.execute({ count: 2, reverse: true });
```

**사용 시나리오**:
- 폼 입력 시 필드 간 이동
- 메뉴 항목 선택
- 접근성 네비게이션

---

### 3.5 SpotlightTool

**파일**: `src/tools/gui/action/SpotlightTool.ts` (91 lines)

#### 목적
macOS Spotlight를 열고 검색을 수행합니다. **macOS 전용** 도구.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    query: {
      type: 'string',
      description: 'Search query for Spotlight',
    },
    pressEnter: {
      type: 'boolean',
      description: 'Press Enter to open the first result (default: true)',
      default: true,
    },
  },
  required: ['query'],
};
```

**파라미터**:
- `query` (필수): Spotlight 검색어
- `pressEnter` (선택): 첫 번째 결과 실행 여부 (기본값: true)

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  // 1. macOS 확인
  if (!isMacOS()) {
    return { success: false, error: 'Spotlight is only available on macOS' };
  }

  // 2. query 필수 확인
  if (!typedInput.query) {
    return { success: false, error: 'query is required' };
  }

  const pressEnter = typedInput.pressEnter !== undefined ? typedInput.pressEnter : true;

  // 3. Spotlight 열기 (Cmd+Space)
  await KeyboardController.pressKey("space", ["command"]);

  // 4. Spotlight 열릴 때까지 대기
  await new Promise((resolve) => setTimeout(resolve, 300));

  // 5. 검색어 타이핑
  KeyboardController.typeText(typedInput.query, 50);

  // 6. 검색 결과 대기
  await new Promise((resolve) => setTimeout(resolve, 500));

  // 7. Enter 키 (옵션)
  if (pressEnter) {
    KeyboardController.pressEnter();
  }

  // 8. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      query: typedInput.query,
      pressEnter,
      platform: 'macos',
    }),
  };
}
```

**단계별 설명**:
1. **플랫폼 체크**: `isMacOS()` - macOS 아니면 에러
2. **query 확인**: 필수 파라미터
3. **Spotlight 열기**: `Cmd+Space` (macOS 기본 단축키)
4. **대기 300ms**: Spotlight 창이 열릴 때까지
5. **검색어 입력**: `typeText(query, 50)` - 50ms 간격
6. **대기 500ms**: 검색 결과가 나올 때까지
7. **Enter 실행 (옵션)**: pressEnter=true면 첫 결과 실행
8. **결과 반환**: query, pressEnter, platform 포함

**타이밍이 중요한 이유**:
- Spotlight가 열리기 전에 타이핑하면 실패
- 검색 결과가 나오기 전에 Enter를 누르면 잘못된 항목 실행
- 300ms, 500ms는 경험적으로 안정적인 값

#### 의존성
- `KeyboardController`: `pressKey()`, `typeText()`, `pressEnter()`
- `utils/platform.ts`: `isMacOS()`

#### 사용 예시

```typescript
// 앱 실행 (Enter 자동)
await spotlightTool.execute({ query: 'Calculator' });

// 파일 검색 (Enter 누르지 않음)
await spotlightTool.execute({ query: 'project.pdf', pressEnter: false });

// 시스템 설정 열기
await spotlightTool.execute({ query: 'System Preferences' });
```

**자주 사용하는 검색**:
- 앱 실행: "Terminal", "Chrome", "Calculator"
- 파일 검색: 파일명
- 시스템 기능: "System Preferences", "Activity Monitor"
- 계산기: "2+2", "100 USD to EUR"

---

## 4. Brain Tools - 네비게이션 도구

Brain Tools는 NavigationBrain과 연동하여 **학습된 네비게이션 경로를 사용**하거나 **현재 화면 상태를 파악**하는 도구들입니다.

### 4.1 NavigateToTool

**파일**: `src/brain/tools/NavigateToTool.ts` (85 lines)

#### 목적
자연어로 목표 화면을 설명하면, NavigationBrain이 경로를 학습하거나 재사용하여 해당 화면으로 네비게이션합니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    target: {
      type: 'string',
      description: 'Natural language description of where to navigate (e.g., "Settings", "Desktop folder", "Terminal")',
    },
  },
  required: ['target'],
};
```

**파라미터**:
- `target` (필수): 목표 화면의 자연어 설명
  - 예: "Settings page", "Desktop folder in Finder", "Chrome preferences"

#### 생성자

```typescript
constructor(private brain: NavigationBrain) {
  super();
}
```

**의존성 주입**: NavigationBrain 인스턴스 필요

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  // 1. target 필수 확인
  if (!typedInput.target) {
    return { success: false, error: 'target is required' };
  }

  console.log(`[NavigateToTool] Navigating to: ${typedInput.target}`);

  // 2. Brain을 통한 네비게이션
  const success = await this.brain.navigateTo(typedInput.target);

  // 3. 실패 처리
  if (!success) {
    return {
      success: false,
      error: `Failed to navigate to "${typedInput.target}". The brain could not learn or execute the path.`,
    };
  }

  // 4. 현재 노드 조회
  const currentNode = this.brain.getCurrentNodeId();

  // 5. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      target: typedInput.target,
      currentNode: currentNode
        ? `${currentNode.programName}::${currentNode.stateHash}`
        : 'unknown',
      message: 'Successfully navigated to target',
    }),
  };
}
```

**단계별 설명**:
1. **target 확인**: 필수 파라미터
2. **brain.navigateTo() 호출**:
   - 기존 경로가 있으면 재사용
   - 없으면 VLM으로 학습 후 실행
3. **실패 처리**: success=false면 에러 반환
4. **현재 노드**: `getCurrentNodeId()` → NodeId
5. **결과 반환**: target, currentNode key, message 포함

**brain.navigateTo() 내부 동작** (복습):
```typescript
async navigateTo(targetDescription: string): Promise<boolean> {
  // 1. 현재 노드 식별
  const fromNodeId = await this.identifyCurrentNode();

  // 2. 기존 경로 검색 (VLM으로 유사도 비교)
  const paths = await this.getPathsFrom(fromNodeId);
  // ... 경로 매칭 로직

  // 3. 기존 경로 있으면 재사용
  if (existingPath) {
    return await this.executePath(existingPath);
  }

  // 4. 없으면 새로 학습
  const newPath = await this.learnPath(targetDescription);
  if (!newPath) return false;

  // 5. 새 경로 실행
  return await this.executePath(newPath);
}
```

#### 의존성
- `NavigationBrain`: `navigateTo()`, `getCurrentNodeId()`

#### 사용 예시

```typescript
// 시스템 설정 열기
await navigateToTool.execute({ target: 'System Preferences' });
// → brain이 Spotlight → "System Preferences" 경로 학습/재사용

// 특정 폴더로 이동
await navigateToTool.execute({ target: 'Desktop folder in Finder' });
// → Finder 열기 → Desktop 클릭

// 앱 내 페이지 이동
await navigateToTool.execute({ target: 'Settings page in Chrome' });
// → Chrome 열기 → 메뉴 → Settings
```

**장점**:
- 한 번 학습하면 JSON에 저장되어 재사용
- 비용 절감 (VLM 호출 최소화)
- 안정적 (검증된 경로)

---

### 4.2 GetCurrentNodeTool

**파일**: `src/brain/tools/GetCurrentNodeTool.ts` (72 lines)

#### 목적
현재 화면의 **Node 정보, ShadowDOM, 사용 가능한 경로**를 조회합니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {},
};
```

**파라미터**: 없음 (입력 불필요)

#### 생성자

```typescript
constructor(private brain: NavigationBrain) {
  super();
}
```

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  console.log('[GetCurrentNodeTool] Identifying current node...');

  // 1. 현재 노드 식별
  const nodeId = await this.brain.identifyCurrentNode();

  // 2. 현재 노드에서 사용 가능한 경로 조회
  const paths = await this.brain.getPathsFrom(nodeId);

  // 3. 전체 그래프 노드 개수 (통계)
  const allNodes = this.brain.getAllNodes();

  // 4. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      currentNode: {
        programName: nodeId.programName,
        stateHash: nodeId.stateHash,
        key: `${nodeId.programName}::${nodeId.stateHash}`,
      },
      availablePaths: paths.map((path) => ({
        id: path.id,
        to: `${path.toNodeId.programName}::${path.toNodeId.stateHash}`,
        actions: path.actions.length,
        successRate: path.metadata.successRate,
        usageCount: path.metadata.usageCount,
      })),
      graphStats: {
        totalNodes: allNodes.length,
        totalPaths: paths.length,
      },
    }),
  };
}
```

**단계별 설명**:
1. **현재 노드 식별**: `brain.identifyCurrentNode()`
   - 화면 캡처 → OCR → VLM → StateHash 생성 → NodeId
2. **사용 가능한 경로**: `brain.getPathsFrom(nodeId)`
   - 현재 노드에서 출발하는 모든 Path
3. **그래프 통계**: `brain.getAllNodes()` → 총 노드 개수
4. **결과 반환**:
   - `currentNode`: programName, stateHash, key
   - `availablePaths`: 각 경로의 id, to, actions 개수, successRate, usageCount
   - `graphStats`: 총 노드 개수, 총 경로 개수

**반환 예시**:
```json
{
  "currentNode": {
    "programName": "Finder",
    "stateHash": "a3b2c1d4e5f6...",
    "key": "Finder::a3b2c1d4e5f6..."
  },
  "availablePaths": [
    {
      "id": "path-1",
      "to": "Finder::desktop-view",
      "actions": 2,
      "successRate": 1.0,
      "usageCount": 5
    }
  ],
  "graphStats": {
    "totalNodes": 12,
    "totalPaths": 1
  }
}
```

#### 의존성
- `NavigationBrain`: `identifyCurrentNode()`, `getPathsFrom()`, `getAllNodes()`

#### 사용 예시

```typescript
// 현재 화면 정보 조회
const result = await getCurrentNodeTool.execute({});

// 결과 파싱
const data = JSON.parse(result.data);
console.log(`현재: ${data.currentNode.programName}`);
console.log(`사용 가능한 경로: ${data.availablePaths.length}개`);
```

**사용 시나리오**:
- 현재 위치 확인
- 어디로 갈 수 있는지 파악
- 그래프 통계 확인 (학습 진행도)

---

### 4.3 LaunchAppTool

**파일**: `src/brain/tools/LaunchAppTool.ts` (87 lines)

#### 목적
macOS Spotlight를 통해 애플리케이션을 실행합니다. **Brain 시스템의 기본 노드인 Spotlight를 활용**.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    appName: {
      type: 'string',
      description: 'Name of the application to launch (e.g., "Calculator", "Terminal", "Chrome")',
    },
  },
  required: ['appName'],
};
```

**파라미터**:
- `appName` (필수): 실행할 앱 이름
  - 예: "Calculator", "Terminal", "Google Chrome"

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  // 1. appName 필수 확인
  if (!typedInput.appName) {
    return { success: false, error: 'appName is required' };
  }

  console.log(`[LaunchAppTool] Launching ${typedInput.appName} via Spotlight...`);

  // 2. Spotlight 열기 (Cmd+Space)
  await KeyboardController.pressKey("space", ["command"]);
  await new Promise((resolve) => setTimeout(resolve, 300));

  // 3. 앱 이름 타이핑
  KeyboardController.typeText(typedInput.appName, 50);

  // 4. 검색 결과 대기
  await new Promise((resolve) => setTimeout(resolve, 500));

  // 5. Enter 키로 실행
  KeyboardController.pressEnter();

  // 6. 앱 실행 대기
  await new Promise((resolve) => setTimeout(resolve, 2000));

  console.log(`[LaunchAppTool] Successfully launched ${typedInput.appName}`);

  // 7. 결과 반환
  return {
    success: true,
    data: JSON.stringify({
      appName: typedInput.appName,
      method: 'spotlight',
      message: `Successfully launched ${typedInput.appName} via Spotlight`,
    }),
  };
}
```

**단계별 설명**:
1. **appName 확인**: 필수 파라미터
2. **Spotlight 열기**: `Cmd+Space` → 300ms 대기
3. **앱 이름 입력**: `typeText(appName, 50)`
4. **검색 대기**: 500ms (Spotlight 검색 결과)
5. **Enter 실행**: 첫 번째 결과 (보통 정확한 앱)
6. **앱 실행 대기**: 2000ms (앱이 완전히 열릴 때까지)
7. **결과 반환**: appName, method, message

**SpotlightTool과의 차이**:
- SpotlightTool: 일반적인 Spotlight 검색 (파일, 계산 등)
- LaunchAppTool: **앱 실행 전용** (2초 대기로 앱 실행 확실히 보장)

**Brain 시스템과의 관계**:
- Spotlight는 **"시스템 레벨 노드"**
- 어디서든 `Cmd+Space`로 접근 가능
- 앱 실행의 시작점으로 활용

#### 의존성
- `KeyboardController`: `pressKey()`, `typeText()`, `pressEnter()`

#### 사용 예시

```typescript
// Calculator 실행
await launchAppTool.execute({ appName: 'Calculator' });

// Terminal 실행
await launchAppTool.execute({ appName: 'Terminal' });

// Chrome 실행
await launchAppTool.execute({ appName: 'Google Chrome' });
```

**팁**:
- 정확한 앱 이름 사용 (Spotlight 검색 정확도 향상)
- 예: "Chrome" 대신 "Google Chrome"

---

## 5. 테스트 도구

### 5.1 EchoTool

**파일**: `src/tools/gui/EchoTool.ts` (42 lines)

#### 목적
입력받은 메시지를 그대로 반환하는 **테스트용 도구**입니다. LLM의 도구 호출 기능을 검증하는 데 사용됩니다.

#### 입력 스키마

```typescript
readonly inputSchema = {
  type: 'object',
  properties: {
    message: {
      type: 'string',
      description: 'The message to echo back',
    },
  },
  required: ['message'],
};
```

**파라미터**:
- `message` (필수): 에코할 메시지

#### 실행 로직

```typescript
async execute(input: ToolInput): Promise<ToolResult> {
  this.validateInput(input);

  return {
    success: true,
    data: JSON.stringify({
      echo: typedInput.message,
      timestamp: new Date().toISOString(),
    }),
  };
}
```

**매우 단순**:
- 입력받은 message를 그대로 반환
- timestamp 추가

#### 사용 예시

```typescript
const result = await echoTool.execute({ message: 'Hello World' });
// → { success: true, data: '{"echo":"Hello World","timestamp":"2026-02-15T..."}' }
```

**용도**:
- Tool calling 동작 확인
- LLM → ToolRegistry → Tool 실행 흐름 테스트
- 개발 중 디버깅

---

## 6. 도구 등록 및 실행 흐름

### 6.1 도구 등록 (index.ts)

```typescript
// 1. ToolRegistry 생성
const toolRegistry = new ToolRegistry();

// 2. Vision Tools 등록
toolRegistry.register(new EchoTool());
toolRegistry.register(new ScreenReaderTool(llmManager.getAdapter()));
toolRegistry.register(new SmartScreenReaderTool(llmManager));
toolRegistry.register(new ScreenCaptureTool());
toolRegistry.register(new OCRTool());

// 3. Action Tools 등록
toolRegistry.register(new ClickTool());
toolRegistry.register(new TypeTool());
toolRegistry.register(new KeyPressTool());
toolRegistry.register(new TabNavigateTool());
toolRegistry.register(new SpotlightTool());

// 4. Brain 초기화 후 Brain Tools 등록
const brain = new NavigationBrain(brainStorage, llmManager);
await brain.initialize();

toolRegistry.register(new NavigateToTool(brain));
toolRegistry.register(new GetCurrentNodeTool(brain));
toolRegistry.register(new LaunchAppTool());
```

**등록 순서**:
1. 기본 도구 (Echo, ScreenReader, SmartScreenReader)
2. Vision Tools (ScreenCapture, OCR)
3. Action Tools (Click, Type, KeyPress, TabNavigate, Spotlight)
4. Brain 초기화
5. Brain Tools (NavigateTo, GetCurrentNode, LaunchApp)

### 6.2 도구 실행 흐름

```
User Request: "Chrome의 Settings 페이지로 이동"
  ↓
Agent.processRequest()
  ↓
LLMManager.send(tools)
  ↓
LLM Response:
  toolCalls: [
    { name: 'navigate_to', input: { target: 'Settings page in Chrome' } }
  ]
  ↓
ToolRegistry.execute(toolCall)
  ↓
NavigateToTool.execute({ target: 'Settings page in Chrome' })
  ↓
NavigationBrain.navigateTo('Settings page in Chrome')
  ↓
1. identifyCurrentNode() → 현재 위치 확인
2. getPathsFrom(nodeId) → 기존 경로 검색
3. learnPath() or executePath() → 경로 학습 또는 재사용
4. executeAction() * N → 액션 실행 (click, type, etc.)
  ↓
각 액션 실행 시:
  - ClickTool.execute()
  - TypeTool.execute()
  - KeyPressTool.execute()
  등...
  ↓
ToolResult 반환
  ↓
LLMManager.addToolResult()
  ↓
LLM 다시 호출 (agentic loop)
  ↓
최종 응답
```

### 6.3 도구 간 의존성

```
NavigateToTool
  ↓
NavigationBrain
  ↓
executeAction()
  ↓
ClickTool, TypeTool, KeyPressTool, etc.
  ↓
MouseController, KeyboardController
  ↓
@nut-tree-fork/nut-js (native automation)
```

**Brain Tools가 Action Tools를 간접적으로 사용**:
- NavigationBrain이 Action을 실행할 때 MouseController/KeyboardController 사용
- Action Tools는 LLM이 직접 호출할 수도 있고, Brain이 간접 호출할 수도 있음

### 6.4 도구 정의 생성 흐름

```typescript
// Agent.processRequest() 내부
const tools = this.toolRegistry.getDefinitions();
// → ToolBase.getDefinition() * N 호출
// → ToolDefinition[] 생성

// LLM에 전달
const response = await this.llmManager.send(tools);
// → AnthropicLLM이 tools를 API에 전달
// → LLM이 적절한 도구 선택 후 toolCalls 반환
```

**ToolDefinition 예시**:
```json
[
  {
    "name": "click",
    "description": "Click at specific coordinates or search for text...",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" },
        "text": { "type": "string" },
        ...
      }
    }
  },
  {
    "name": "navigate_to",
    "description": "Navigate to a specific screen or state...",
    "input_schema": { ... }
  }
]
```

---

## 정리

### 도구 개수 및 분류

| 분류 | 개수 | 도구명 |
|------|------|--------|
| Vision Tools | 3개 (실제) + 1개 (deprecated) | SmartScreenReader, ScreenCapture, OCR, ~~ScreenReader~~ |
| Action Tools | 5개 | Click, Type, KeyPress, TabNavigate, Spotlight |
| Brain Tools | 3개 | NavigateTo, GetCurrentNode, LaunchApp |
| Test Tools | 1개 | Echo |
| **총계** | **12개** (deprecated 제외 13개) | |

### 핵심 개념

1. **ToolBase 추상 클래스**:
   - 모든 도구의 기반
   - name, description, inputSchema, execute() 필수 구현
   - getDefinition(), validateInput(), hasLLM() 공통 메서드

2. **Vision Tools**:
   - 화면 분석 (OCR, Vision LLM)
   - SmartScreenReaderTool: quick/detailed 모드로 비용/속도 최적화

3. **Action Tools**:
   - GUI 직접 조작 (마우스, 키보드)
   - ClickTool: Coordinate/OCR 두 가지 모드
   - Modifier keys 지원 (Cmd, Ctrl, Alt, Shift)

4. **Brain Tools**:
   - NavigationBrain과 연동
   - 학습된 경로 재사용 (JSON 기반)
   - 비용 절감 + 안정성 향상

5. **도구 실행 흐름**:
   - LLM → ToolCall → ToolRegistry.execute() → Tool.execute() → ToolResult
   - Agent가 agentic loop로 반복 호출

6. **의존성 주입**:
   - SmartScreenReaderTool: LLMManager 필요
   - NavigateToTool, GetCurrentNodeTool: NavigationBrain 필요
   - 나머지: 자체 로직 (MouseController, KeyboardController 사용)

### 파일 크기

| 파일 | 라인 수 |
|------|---------|
| ToolBase.ts | 56 |
| SmartScreenReader.ts | 170 |
| ClickTool.ts | 166 |
| OCRTool.ts | 107 |
| SpotlightTool.ts | 91 |
| ScreenCaptureTool.ts | 89 |
| LaunchAppTool.ts | 87 |
| TypeTool.ts | 82 |
| TabNavigateTool.ts | 76 |
| ScreenReader.ts | 71 (deprecated) |
| GetCurrentNodeTool.ts | 72 |
| NavigateToTool.ts | 85 |
| KeyPressTool.ts | 78 |
| EchoTool.ts | 42 |

**가장 복잡한 도구**: SmartScreenReaderTool (170 lines) - LLM mode 처리 + OCR 통합
