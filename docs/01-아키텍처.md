# GAI 아키텍처

## 목차

1. [전체 아키텍처](#전체-아키텍처)
2. [계층 구조](#계층-구조)
3. [컴포넌트 다이어그램](#컴포넌트-다이어그램)
4. [핵심 디자인 패턴](#핵심-디자인-패턴)
5. [타입 시스템](#타입-시스템)
6. [의존성 그래프](#의존성-그래프)
7. [확장성 설계](#확장성-설계)
8. [데이터 흐름](#데이터-흐름)

---

## 전체 아키텍처

GAI는 **Layered Architecture**를 기반으로 설계되었습니다.

### 5계층 구조

```
┌─────────────────────────────────────────────────┐
│  Layer 1: Entry Point (index.ts)               │
│  - 초기화 오케스트레이션                        │
│  - 권한 확인, 설정 로드                         │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  Layer 2: Core (Agent, ToolRegistry)           │
│  - 에이전트 루프                                │
│  - 도구 관리 및 실행                            │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  Layer 3: LLM (LLMManager, Providers)          │
│  - 멀티모드 LLM 관리                            │
│  - 4개 제공자 추상화                            │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  Layer 4: Domain Logic                         │
│  ├─ Brain (NavigationBrain)                    │
│  ├─ Tools (12개 도구)                          │
│  └─ Config (ConfigLoader)                      │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  Layer 5: Infrastructure                       │
│  ├─ Utils (Automation, OCR, Permissions)       │
│  ├─ Storage (JSONStorage)                      │
│  └─ External APIs (Anthropic, OpenAI, etc.)    │
└─────────────────────────────────────────────────┘
```

### 계층별 책임

| 계층 | 책임 | 주요 컴포넌트 |
|------|------|---------------|
| **Entry Point** | 초기화 및 실행 | index.ts |
| **Core** | 에이전트 루프 및 도구 관리 | Agent, ToolRegistry |
| **LLM** | LLM 추상화 및 멀티모드 관리 | LLMManager, BaseLLM, 4개 제공자 |
| **Domain Logic** | 비즈니스 로직 | NavigationBrain, Tools, Config |
| **Infrastructure** | 저수준 기능 | Automation, OCR, Storage |

---

## 계층 구조

### Layer 1: Entry Point

**파일**: `src/index.ts` (178줄)

**책임**:
- 권한 확인 (macOS)
- 설정 로드 및 검증
- 모든 컴포넌트 초기화
- 사용자 요청 처리
- 세션 관리

**초기화 순서**:
```
1. Permission Check (macOS)
2. ConfigLoader
3. LLMManager
4. ToolRegistry
5. NavigationBrain
6. 12 Tools Registration
7. Agent
8. User Request Processing
```

### Layer 2: Core

**파일**:
- `src/core/Agent.ts` (156줄)
- `src/core/ToolRegistry.ts` (91줄)
- `src/core/types.ts` (211줄)

**책임**:
- **Agent**: 에이전트 루프 오케스트레이션 (최대 10회 반복)
- **ToolRegistry**: 도구 등록 및 실행 관리 (Map 기반)
- **types**: 전체 타입 시스템 (43개 exported types)

**핵심 로직**:
```typescript
// Agent.processRequest()
while (iteration < maxIterations) {
  const response = await this.llmManager.send(tools);

  if (response.toolCalls) {
    const results = await this.executeToolCalls(response.toolCalls);
    for (const result of results) {
      this.llmManager.addToolResult(result.toolCallId, result);
    }
    continue;
  }

  return response.content; // 최종 응답
}
```

### Layer 3: LLM

**파일**:
- `src/llm/LLMManager.ts` (181줄)
- `src/llm/base/BaseLLM.ts` (68줄)
- `src/llm/providers/` (4개 파일, 평균 262줄)

**책임**:
- **LLMManager**: 멀티모드 관리 (default/fast/vision)
- **BaseLLM**: LLM 추상 클래스 (히스토리 관리)
- **Providers**: 4개 LLM 제공자 구현

**모드 시스템**:
```typescript
interface LLMModeConfig {
  default: ProviderConfig;
  fast?: ProviderConfig;    // fallback to default
  vision?: ProviderConfig;  // fallback to default
}
```

### Layer 4: Domain Logic

#### Brain (Navigation Brain)

**파일**:
- `src/brain/NavigationBrain.ts` (757줄) ⭐
- `src/brain/utils/VLMAnalyzer.ts` (268줄)
- `src/brain/utils/StateHasher.ts` (103줄)
- `src/brain/storage/JSONStorage.ts` (256줄)

**아키텍처**:
```
NavigationBrain
├─ NavigationGraph (in-memory)
│  ├─ Nodes (Map<NodeIdKey, Node>)
│  └─ Paths (Map<string, Path>)
├─ ShadowDOM (runtime snapshot)
│  ├─ Screenshot (PNG buffer)
│  ├─ UI Elements (from VLM)
│  ├─ OCR Result
│  └─ Instance Hash
└─ Storage (persistence)
   └─ JSONStorage → data/brain/navigation.json
```

#### Tools (12개 도구)

**파일**: `src/tools/` (13개 파일)

**계층**:
```
ToolBase (abstract)
├─ Vision Tools
│  ├─ SmartScreenReaderTool
│  ├─ ScreenCaptureTool
│  ├─ OCRTool
│  └─ ScreenReaderTool
├─ Action Tools
│  ├─ ClickTool
│  ├─ TypeTool
│  ├─ KeyPressTool
│  ├─ TabNavigateTool
│  └─ SpotlightTool
└─ Brain Tools
   ├─ NavigateToTool
   ├─ GetCurrentNodeTool
   └─ LaunchAppTool
```

#### Config

**파일**: `src/config/ConfigLoader.ts` (300줄)

**3계층 로딩**:
```
기본값 (코드 내부)
    ↓ merge
JSON 파일 (config/config.json)
    ↓ override
환경변수 (.env) ← 최우선
```

### Layer 5: Infrastructure

#### Automation

**파일**:
- `src/utils/automation/MouseController.ts` (118줄)
- `src/utils/automation/KeyboardController.ts` (193줄)
- `src/utils/automation/CoordinateConverter.ts` (68줄)

**책임**:
- MouseController: nut.js 기반 마우스 제어
- KeyboardController: nut.js 기반 키보드 제어
- CoordinateConverter: Pixel ↔ Normalized 변환

#### OCR

**파일**:
- `src/utils/ocr/OCRProvider.ts` (20줄) - 추상 인터페이스
- `src/utils/ocr/MacOCRProvider.ts` (80줄) - macOS 구현
- `src/utils/ocr/OCRFactory.ts` (42줄) - 팩토리

**Factory Pattern**:
```typescript
class OCRFactory {
  static create(): OCRProvider | null {
    if (isMacOS()) {
      return new MacOCRProvider();
    }
    // 향후: WindowsOCRProvider, LinuxOCRProvider
    return null;
  }
}
```

#### Permissions

**파일**: `src/utils/permissions/MacPermissions.ts` (60줄)

**책임**: macOS Accessibility + Screen Recording 권한

---

## 컴포넌트 다이어그램

### 전체 컴포넌트

```
┌─────────────────────────────────────────────────────────────┐
│                        index.ts                              │
│  - Permission Check                                          │
│  - Initialization Orchestration                              │
└──────────────────────┬──────────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
┌───────▼──────┐  ┌───▼─────┐  ┌────▼────────┐
│ ConfigLoader │  │  Agent  │  │ ToolRegistry│
│              │  │         │  │             │
│ - 3-tier     │  │ - Loop  │  │ - Register  │
│   loading    │  │ - Max10 │  │ - Execute   │
└───────┬──────┘  └───┬─────┘  └────┬────────┘
        │             │              │
        │     ┌───────▼──────┐       │
        │     │  LLMManager  │       │
        │     │              │       │
        │     │ - Modes (3)  │       │
        └────►│ - Providers  │       │
              └───────┬──────┘       │
                      │              │
         ┌────────────┼──────────────┘
         │            │
    ┌────▼────┐  ┌───▼──────────┐
    │ Brain   │  │  12 Tools    │
    │         │  │              │
    │ - Graph │  │ - Vision (4) │
    │ - VLM   │  │ - Action (5) │
    │ - OCR   │  │ - Brain (3)  │
    └────┬────┘  └───┬──────────┘
         │           │
    ┌────▼───────────▼─────┐
    │   Infrastructure     │
    │                      │
    │ - Automation         │
    │ - OCR                │
    │ - Storage            │
    │ - Permissions        │
    └──────────────────────┘
```

### NavigationBrain 상세

```
┌───────────────────────────────────────────────────────┐
│              NavigationBrain (757줄)                   │
├───────────────────────────────────────────────────────┤
│                                                       │
│  Public API (20+ methods)                            │
│  ├─ navigateTo(target)                               │
│  ├─ identifyCurrentNode()                            │
│  ├─ learnPath(target)                                │
│  ├─ executePath(path)                                │
│  ├─ getShadowDOM()                                   │
│  └─ addNode(), getAllNodes(), getPathsFrom()...      │
│                                                       │
├───────────────────────────────────────────────────────┤
│                                                       │
│  Internal State                                      │
│  ├─ navigationGraph: NavigationGraph                 │
│  │  ├─ nodes: Map<NodeIdKey, Node>                  │
│  │  └─ paths: Map<string, Path>                     │
│  ├─ shadowDOM: ShadowDOM | null                      │
│  └─ currentNodeId: NodeId | null                     │
│                                                       │
├───────────────────────────────────────────────────────┤
│                                                       │
│  Dependencies                                        │
│  ├─ storage: BrainStorage (JSONStorage)              │
│  ├─ llmManager: LLMManager                           │
│  ├─ vlmAnalyzer: VLMAnalyzer                         │
│  ├─ ocrFactory: OCRFactory                           │
│  ├─ mouseController: MouseController                 │
│  └─ keyboardController: KeyboardController           │
│                                                       │
└───────────────────────────────────────────────────────┘
```

---

## 핵심 디자인 패턴

### 1. Strategy Pattern (전략 패턴)

**사용 위치**: LLM Providers

**구조**:
```typescript
// 전략 인터페이스
abstract class BaseLLM {
  abstract send(tools?): Promise<LLMResponse>;
  abstract stream(tools?): AsyncIterableIterator<LLMStreamChunk>;
}

// 구체적 전략들
class AnthropicLLM extends BaseLLM { /* ... */ }
class OpenAILLM extends BaseLLM { /* ... */ }
class GoogleLLM extends BaseLLM { /* ... */ }
class OllamaLLM extends BaseLLM { /* ... */ }

// 컨텍스트
class LLMManager {
  private defaultLLM: BaseLLM;
  private fastLLM?: BaseLLM;
  private visionLLM?: BaseLLM;

  async send(tools?) {
    return this.defaultLLM.send(tools);
  }

  async sendWithMode(mode: 'default' | 'fast' | 'vision', ...) {
    const llm = this.getLLM(mode);
    return llm.send(...);
  }
}
```

**장점**:
- 런타임에 LLM 제공자 변경 가능
- 새로운 제공자 추가 용이
- 각 제공자의 세부 구현 캡슐화

### 2. Registry Pattern (레지스트리 패턴)

**사용 위치**: ToolRegistry

**구조**:
```typescript
class ToolRegistry {
  private tools: Map<string, ToolBase> = new Map();

  register(tool: ToolBase): void {
    this.tools.set(tool.name, tool);
  }

  async execute(toolCall: ToolCall): Promise<ToolResult> {
    const tool = this.tools.get(toolCall.name);
    if (!tool) {
      throw new Error(`Tool not found: ${toolCall.name}`);
    }
    return tool.execute(toolCall.input);
  }

  getDefinitions(): ToolDefinition[] {
    return Array.from(this.tools.values()).map(tool => tool.getDefinition());
  }
}
```

**장점**:
- 도구를 동적으로 등록/해제 가능
- O(1) 시간 복잡도로 도구 검색
- LLM에 전달할 도구 정의를 쉽게 수집

### 3. Factory Pattern (팩토리 패턴)

**사용 위치**: OCRFactory, LLM 제공자 생성

**구조**:
```typescript
// OCR Factory
class OCRFactory {
  static create(): OCRProvider | null {
    if (isMacOS()) {
      return new MacOCRProvider();
    } else if (isWindows()) {
      // 향후: return new WindowsOCRProvider();
    }
    return null;
  }

  static isSupported(): boolean {
    return isMacOS(); // 향후: || isWindows()
  }
}

// LLM Factory (LLMManager 내부)
private createLLM(config: ProviderConfig): BaseLLM {
  switch (config.provider) {
    case 'anthropic':
      return new AnthropicLLM(config);
    case 'openai':
      return new OpenAILLM(config);
    case 'google':
      return new GoogleLLM(config);
    case 'ollama':
      return new OllamaLLM(config);
    default:
      throw new Error(`Unknown provider: ${config.provider}`);
  }
}
```

**장점**:
- 플랫폼별 구현을 자동으로 선택
- 클라이언트 코드가 구체적 클래스에 의존하지 않음
- 새로운 제공자/플랫폼 추가 용이

### 4. Adapter Pattern (어댑터 패턴)

**사용 위치**: BaseLLM (각 제공자의 메시지 포맷 변환)

**구조**:
```typescript
class AnthropicLLM extends BaseLLM {
  async send(tools?: ToolDefinition[]): Promise<LLMResponse> {
    // 1. 우리 포맷 → Anthropic 포맷 변환
    const anthropicMessages = this.convertToAnthropicFormat(this.history);

    // 2. Anthropic API 호출
    const response = await this.client.messages.create({
      model: this.config.model,
      messages: anthropicMessages,
      tools: tools ? this.convertToolsToAnthropicFormat(tools) : undefined
    });

    // 3. Anthropic 포맷 → 우리 포맷 변환
    return this.convertFromAnthropicFormat(response);
  }

  private convertToAnthropicFormat(messages: Message[]): AnthropicMessage[] {
    // 변환 로직
  }

  private convertFromAnthropicFormat(response: AnthropicResponse): LLMResponse {
    // 변환 로직
  }
}
```

**장점**:
- 각 LLM 제공자의 API 차이를 숨김
- 통일된 인터페이스로 모든 LLM 사용 가능
- Message 포맷이 일관성 있게 유지됨

### 5. Template Method Pattern (템플릿 메서드 패턴)

**사용 위치**: ToolBase

**구조**:
```typescript
abstract class ToolBase {
  abstract name: string;
  abstract description: string;
  abstract inputSchema: object;
  abstract execute(input: any): Promise<ToolResult>;

  // Template method
  getDefinition(): ToolDefinition {
    return {
      name: this.name,
      description: this.description,
      inputSchema: this.inputSchema
    };
  }

  validateInput(input: any): void {
    // 공통 검증 로직
  }

  hasLLM(): boolean {
    return (this as any).llmManager !== undefined;
  }
}
```

**장점**:
- 공통 로직을 기반 클래스에서 구현
- 각 도구는 execute()만 구현하면 됨
- 일관성 있는 도구 정의 생성

### 6. Dependency Injection (의존성 주입)

**사용 위치**: 전체 시스템

**예시**:
```typescript
// NavigationBrain
class NavigationBrain {
  constructor(
    private storage: BrainStorage,     // DI: Storage
    private llmManager: LLMManager     // DI: LLM
  ) {
    this.vlmAnalyzer = new VLMAnalyzer(llmManager);
  }
}

// SmartScreenReaderTool
class SmartScreenReaderTool extends ToolBase {
  constructor(private llmManager: LLMManager) {  // DI: LLM
    super();
  }

  async execute(input: { mode: 'quick' | 'detailed' }) {
    // LLM 사용
    const response = await this.llmManager.sendWithMode(
      input.mode === 'quick' ? 'fast' : 'vision',
      messages
    );
  }
}

// Agent
class Agent {
  constructor(
    private llmManager: LLMManager,       // DI: LLM
    private toolRegistry: ToolRegistry,   // DI: Tools
    private config: AgentConfig
  ) {}
}
```

**장점**:
- 테스트 용이 (Mock 객체 주입 가능)
- 느슨한 결합 (Loose Coupling)
- 구성 변경 용이

---

## 타입 시스템

### 타입 계층 구조

```
src/core/types.ts (211줄, 43개 exported types)
├─ Message Types
│  ├─ Message
│  ├─ ContentBlock (union)
│  │  ├─ TextContent
│  │  ├─ ImageContent
│  │  ├─ ToolUseContent
│  │  └─ ToolResultContent
│  └─ Role: 'user' | 'assistant'
│
├─ Tool Types
│  ├─ ToolDefinition
│  ├─ ToolCall
│  ├─ ToolResult
│  └─ ToolResultContent
│
├─ LLM Types
│  ├─ LLMResponse
│  ├─ LLMStreamChunk
│  ├─ LLMConfig (union)
│  │  ├─ SingleLLMConfig
│  │  └─ LLMModeConfig
│  ├─ ProviderConfig
│  └─ Provider: 'anthropic' | 'openai' | 'google' | 'ollama'
│
├─ Config Types
│  ├─ Config
│  ├─ TelegramConfig
│  ├─ ToolsConfig
│  └─ AgentConfig
│
└─ GUI Types
   ├─ Coordinate (Pixel | Normalized)
   ├─ PixelCoordinate
   ├─ NormalizedCoordinate
   ├─ BBox
   ├─ OCRAnalysis
   └─ OCRElement

src/brain/types.ts (279줄)
├─ Core Types
│  ├─ NodeId { programName, stateHash }
│  ├─ Node
│  ├─ Path
│  ├─ ShadowDOM
│  └─ UIElement
│
├─ Action Types (union)
│  ├─ ClickAction
│  ├─ TypeAction
│  ├─ HotkeyAction
│  ├─ WaitAction
│  ├─ ScrollAction
│  └─ SpotlightAction
│
└─ Graph Types
   ├─ NavigationGraph
   └─ SerializableNavigationGraph
```

### 주요 타입 상세

#### Message (메시지 시스템)

```typescript
interface Message {
  role: 'user' | 'assistant';
  content: ContentBlock[];
}

type ContentBlock =
  | TextContent
  | ImageContent
  | ToolUseContent
  | ToolResultContent;

interface TextContent {
  type: 'text';
  text: string;
}

interface ImageContent {
  type: 'image';
  source: {
    type: 'base64' | 'url';
    media_type: string;
    data: string;
  };
}

interface ToolUseContent {
  type: 'tool_use';
  id: string;
  name: string;
  input: any;
}

interface ToolResultContent {
  type: 'tool_result';
  tool_use_id: string;
  content: string | any;
}
```

#### Node & Path (네비게이션 그래프)

```typescript
interface NodeId {
  programName: string;
  stateHash: string;  // SHA-256 hash
}

interface Node {
  id: NodeId;
  metadata: {
    title?: string;
    screenshot?: Buffer;
    uiElements: UIElement[];
    description?: string;
    createdAt: Date;
    lastVisitedAt: Date;
    visitCount: number;
  };
  childrenIds: NodeId[];
}

interface Path {
  id: string;
  fromNodeId: NodeId;
  toNodeId: NodeId;
  actions: Action[];
  validation: {
    expectedElements?: string[];
    expectedText?: string[];
    timeout?: number;
  };
  verificationHistory?: PathVerification[];
  metadata: {
    successRate: number;
    lastUsed: Date;
    usageCount: number;
    averageDuration?: number;
    learnedBy: 'vlm' | 'user';
  };
}
```

#### Action (액션 타입)

```typescript
type Action =
  | ClickAction
  | TypeAction
  | HotkeyAction
  | WaitAction
  | ScrollAction
  | SpotlightAction;

interface ClickAction {
  type: 'click';
  data: {
    coordinate?: Coordinate;
    text?: string;
    button?: 'left' | 'right' | 'middle';
    doubleClick?: boolean;
  };
}

interface TypeAction {
  type: 'type';
  data: {
    text: string;
    pressEnter?: boolean;
    delay?: number;
  };
}

interface HotkeyAction {
  type: 'hotkey';
  data: {
    key: string;
    modifiers: ('command' | 'ctrl' | 'alt' | 'shift')[];
  };
}
```

#### ShadowDOM (런타임 상태)

```typescript
interface ShadowDOM {
  nodeId: NodeId | null;
  capturedAt: Date;
  screenshot: Buffer;
  uiElements: UIElement[];
  ocrResult?: OCRAnalysis;
  vlmDescription?: string;
  instanceHash?: string;  // Runtime instance hash
}

interface UIElement {
  type: 'button' | 'text' | 'input' | 'link' | 'icon' | 'menu' | 'window' | 'other';
  label?: string;
  text?: string;
  role?: string;
  bbox?: BBox;
  isClickable?: boolean;
  isInteractive?: boolean;
}
```

---

## 의존성 그래프

### 모듈 간 의존성

```
index.ts
├─ depends on → ConfigLoader
├─ depends on → LLMManager
├─ depends on → Agent
├─ depends on → ToolRegistry
├─ depends on → NavigationBrain
├─ depends on → 12 Tools
└─ depends on → MacPermissions

Agent
├─ depends on → LLMManager
└─ depends on → ToolRegistry

ToolRegistry
└─ depends on → ToolBase (abstract)

LLMManager
└─ depends on → BaseLLM
    ├─ AnthropicLLM
    ├─ OpenAILLM
    ├─ GoogleLLM
    └─ OllamaLLM

NavigationBrain
├─ depends on → BrainStorage (JSONStorage)
├─ depends on → LLMManager
├─ depends on → VLMAnalyzer
├─ depends on → StateHasher
├─ depends on → OCRFactory
├─ depends on → MouseController
└─ depends on → KeyboardController

Tools
├─ SmartScreenReaderTool → LLMManager
├─ NavigateToTool → NavigationBrain
├─ GetCurrentNodeTool → NavigationBrain
├─ ClickTool → OCRFactory, MouseController
└─ (기타 도구) → MouseController, KeyboardController

Utilities
├─ MouseController → CoordinateConverter
├─ MacOCRProvider → CoordinateConverter
└─ OCRFactory → MacOCRProvider
```

### 순환 의존성 없음

GAI는 **단방향 의존성**을 유지합니다:
- 상위 계층 → 하위 계층 (O)
- 하위 계층 → 상위 계층 (X)

예:
- Agent → LLMManager (O)
- LLMManager → Agent (X)

---

## 확장성 설계

### 1. 새로운 LLM 제공자 추가

```typescript
// src/llm/providers/GrokLLM.ts
import { BaseLLM } from '../base/BaseLLM';

export class GrokLLM extends BaseLLM {
  async send(tools?: ToolDefinition[]): Promise<LLMResponse> {
    // Grok API 호출
    // Message 변환
    // Response 변환
  }

  async *stream(tools?: ToolDefinition[]): AsyncIterableIterator<LLMStreamChunk> {
    // Grok streaming API 호출
  }
}

// src/llm/LLMManager.ts에 추가
private createLLM(config: ProviderConfig): BaseLLM {
  switch (config.provider) {
    // ...
    case 'grok':
      return new GrokLLM(config);
    // ...
  }
}
```

### 2. 새로운 도구 추가

```typescript
// src/tools/gui/action/ScrollTool.ts
import { ToolBase } from '../../ToolBase';

export class ScrollTool extends ToolBase {
  name = 'scroll';
  description = '화면을 스크롤합니다';

  inputSchema = {
    type: 'object',
    properties: {
      amount: { type: 'number', description: '스크롤 양' },
      direction: { type: 'string', enum: ['up', 'down', 'left', 'right'] }
    },
    required: ['amount', 'direction']
  };

  async execute(input: { amount: number; direction: string }): Promise<ToolResult> {
    // 스크롤 구현
    await MouseController.scroll(input.amount, input.direction);
    return { success: true };
  }
}

// index.ts에 등록
toolRegistry.register(new ScrollTool());
```

### 3. 새로운 스토리지 백엔드 추가

```typescript
// src/brain/storage/PostgreSQLStorage.ts
import { BrainStorage } from './BrainStorage';
import { Pool } from 'pg';

export class PostgreSQLStorage implements BrainStorage {
  private pool: Pool;

  constructor(connectionString: string) {
    this.pool = new Pool({ connectionString });
  }

  async load(): Promise<SerializableNavigationGraph | null> {
    // PostgreSQL에서 로드
    const nodes = await this.pool.query('SELECT * FROM nodes');
    const paths = await this.pool.query('SELECT * FROM paths');
    // Deserialize
  }

  async save(graph: SerializableNavigationGraph): Promise<void> {
    // PostgreSQL에 저장
    await this.pool.query('BEGIN');
    // ... UPSERT nodes
    // ... UPSERT paths
    await this.pool.query('COMMIT');
  }

  // 기타 메서드 구현
}

// NavigationBrain 초기화 시 사용
const storage = new PostgreSQLStorage(process.env.DATABASE_URL);
const brain = new NavigationBrain(storage, llmManager);
```

### 4. 새로운 플랫폼 지원 (Windows)

```typescript
// src/utils/ocr/WindowsOCRProvider.ts
import { OCRProvider, OCRAnalysis } from './OCRProvider';

export class WindowsOCRProvider implements OCRProvider {
  async analyze(imagePath: string): Promise<OCRAnalysis> {
    // Windows.Media.Ocr API 사용
  }

  async analyzeBuffer(imageBuffer: Buffer): Promise<OCRAnalysis> {
    // Buffer → Windows OCR
  }
}

// src/utils/ocr/OCRFactory.ts 수정
class OCRFactory {
  static create(): OCRProvider | null {
    if (isMacOS()) {
      return new MacOCRProvider();
    } else if (isWindows()) {
      return new WindowsOCRProvider();  // 추가
    }
    return null;
  }

  static isSupported(): boolean {
    return isMacOS() || isWindows();  // 수정
  }
}
```

---

## 데이터 흐름

### 사용자 요청 → 응답

```
사용자 입력 (CLI)
    ↓
index.ts (main)
    ↓
Agent.processRequest()
    ↓
┌─────────────────────────────────┐
│      Agentic Loop (max 10)      │
│                                 │
│  LLMManager.send(tools)         │
│       ↓                         │
│  LLM Response                   │
│       ↓                         │
│  Tool Calls?                    │
│  ├─ Yes → Execute Tools         │
│  │         ↓                    │
│  │    Add Tool Results          │
│  │         ↓                    │
│  │    Loop Again                │
│  │                              │
│  └─ No → Return Final Response  │
└─────────────────────────────────┘
    ↓
최종 응답 출력
```

### NavigateTo 흐름

```
brain.navigateTo("Settings")
    ↓
┌─────────────────────────────┐
│ 1. Check Existing Path      │
│    JSON에 경로 있음?         │
│    ├─ Yes → executePath()   │
│    └─ No  → learnPath()     │
└─────────────────────────────┘
    ↓ (No)
┌─────────────────────────────┐
│ 2. learnPath()              │
│    - VLM 분석               │
│    - Action[] 생성          │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 3. executePath()            │
│    for each action:         │
│      - executeAction()      │
│      - delay(500)           │
│      - updateShadowDOM()    │
│      - verifyActionResult() │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 4. identifyCurrentNode()    │
│    - 도착 검증              │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 5. storage.addPath()        │
│    - JSON에 Path 저장       │
└─────────────────────────────┘
```

### ShadowDOM 업데이트 흐름

```
updateShadowDOM(nodeId)
    ↓
┌─────────────────────────────┐
│ 1. captureScreenBuffer()    │
│    → PNG Buffer             │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 2. OCR Analysis             │
│    MacOCRProvider.analyze() │
│    → OCRAnalysis            │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 3. VLM Analysis             │
│    VLMAnalyzer.identify...()│
│    → UIElement[]            │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 4. State Hashing            │
│    StateHasher.hash...()    │
│    → instanceHash           │
└─────────────────────────────┘
    ↓
┌─────────────────────────────┐
│ 5. Create ShadowDOM         │
│    this.shadowDOM = {       │
│      nodeId,                │
│      screenshot,            │
│      uiElements,            │
│      ocrResult,             │
│      instanceHash           │
│    }                        │
└─────────────────────────────┘
```

---

## 요약

GAI는 다음과 같은 아키텍처 원칙을 따릅니다:

1. **Layered Architecture**: 5계층 구조로 명확한 책임 분리
2. **디자인 패턴**: Strategy, Registry, Factory, Adapter, Template Method, DI
3. **단방향 의존성**: 순환 의존성 없음
4. **확장 가능**: 새로운 LLM, 도구, 스토리지, 플랫폼 쉽게 추가
5. **타입 안전성**: TypeScript strict mode로 타입 안전성 보장
6. **모듈화**: 각 모듈이 독립적으로 동작 가능

다음 문서에서는 각 시스템의 상세 구현을 다룹니다.
