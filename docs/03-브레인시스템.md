# 브레인 시스템 (Navigation Brain)

## 목차

1. [개요](#개요)
2. [NavigationBrain (757줄)](#navigationbrain-757줄)
3. [VLMAnalyzer (268줄)](#vlmanalyzer-268줄)
4. [StateHasher (103줄)](#statehasher-103줄)
5. [스토리지 시스템](#스토리지-시스템)
6. [Brain Tools (3개)](#brain-tools-3개)
7. [핵심 개념](#핵심-개념)
8. [사용 예시](#사용-예시)

---

## 개요

브레인 시스템은 GAI의 **가장 핵심적인 컴포넌트**로, GUI 네비게이션 경로를 학습하고 재사용하는 시스템입니다.

### 구성 요소

| 컴포넌트 | 파일 | 라인 수 | 역할 |
|----------|------|---------|------|
| **NavigationBrain** | NavigationBrain.ts | 757 | GUI 네비게이션 학습 및 실행 엔진 |
| **VLMAnalyzer** | VLMAnalyzer.ts | 268 | VLM 분석 래퍼 |
| **StateHasher** | StateHasher.ts | 103 | 상태 해싱 및 유사도 계산 |
| **BrainStorage** | BrainStorage.ts | 67 | 추상 스토리지 인터페이스 |
| **JSONStorage** | JSONStorage.ts | 256 | JSON 파일 기반 영속성 |
| **NavigateToTool** | NavigateToTool.ts | 85 | 네비게이션 도구 |
| **GetCurrentNodeTool** | GetCurrentNodeTool.ts | 82 | 현재 노드 조회 |
| **LaunchAppTool** | LaunchAppTool.ts | 106 | 앱 실행 도구 |

**총 7개 파일, 약 1,840줄**

### 핵심 아이디어

1. **한 번 학습, 여러 번 재사용**: VLM이 GUI 경로를 한 번 학습하면 JSON에 저장하여 다음번에는 VLM 호출 없이 바로 실행
2. **그래프 구조**: GUI 네비게이션을 그래프로 모델링 (Nodes + Paths)
3. **ShadowDOM**: 런타임 화면 상태를 메모리에 캐싱하여 빠른 검증
4. **OCR + VLM 시너지**: OCR로 텍스트를 정확하게 추출하고, VLM으로 시각적 요소 인식

---

## NavigationBrain (757줄)

**파일**: `src/brain/NavigationBrain.ts` (757줄)

### 목적

NavigationBrain은 **GUI 네비게이션 학습 및 실행 엔진**입니다. 현재 화면을 인식하고, 목표 화면으로 가는 경로를 학습하며, 학습한 경로를 재사용합니다.

### 클래스 구조

```typescript
export class NavigationBrain {
  private graph: NavigationGraph | null = null;      // 네비게이션 그래프 (in-memory)
  private vlmAnalyzer: VLMAnalyzer;                  // VLM 분석 래퍼
  private shadowDOM: ShadowDOM | null = null;        // 런타임 화면 상태 (휘발성)

  constructor(
    private storage: BrainStorage,    // DI: 영속성 계층
    private llmManager: LLMManager    // DI: LLM 관리자
  )
}
```

**데이터 구조**:

```typescript
// 네비게이션 그래프
interface NavigationGraph {
  nodes: Map<string, Node>;           // NodeIdKey → Node
  edges: Map<string, Path>;           // PathId → Path
  currentNodeId: NodeId | null;       // 현재 노드
}

// 노드 (정적인 "장소")
interface Node {
  id: NodeId;                         // { programName, stateHash }
  metadata: {
    title?: string;
    screenshot?: Buffer;
    uiElements: UIElement[];
    description?: string;
    createdAt: Date;
    lastVisitedAt: Date;
    visitCount: number;
  };
  childrenIds: NodeId[];              // 자식 노드 목록
}

// 경로 (노드 간 이동 방법)
interface Path {
  id: string;
  fromNodeId: NodeId;
  toNodeId: NodeId;
  actions: Action[];                  // 액션 시퀀스
  validation: {
    expectedElements?: string[];
    expectedText?: string[];
    timeout?: number;
  };
  verificationHistory?: PathVerification[];
  metadata: {
    successRate: number;              // 성공률 (0-1)
    lastUsed: Date;
    usageCount: number;
    averageDuration?: number;         // 평균 실행 시간 (ms)
    learnedBy: 'vlm' | 'user';
  };
}

// 섀도우DOM (런타임 스냅샷)
interface ShadowDOM {
  nodeId: NodeId | null;
  capturedAt: Date;
  screenshot: string;                 // base64 PNG
  uiElements: UIElement[];
  ocrResult?: OCRAnalysis;
  vlmDescription?: string;
  instanceHash?: string;              // 런타임 인스턴스 해시
}
```

### Public API (20+ methods)

#### 1. initialize(): Promise<boolean>

브레인을 초기화합니다 (JSON에서 그래프 로드).

**시그니처**:
```typescript
async initialize(): Promise<boolean>
```

**내부 로직**:
```typescript
async initialize(): Promise<boolean> {
  try {
    // 1. JSON에서 그래프 로드
    this.graph = await this.storage.load();

    // 2. Spotlight 기본 노드 초기화
    await this.initializeSpotlightNode();

    console.log(
      `[Brain] Initialized with ${this.graph.nodes.size} nodes and ${this.graph.edges.size} edges`
    );
    return true;
  } catch (error) {
    console.error(`[Brain] Failed to initialize: ${error.message}`);
    return false;
  }
}
```

**Spotlight 노드**:
```typescript
private async initializeSpotlightNode(): Promise<void> {
  const spotlightNodeId: NodeId = {
    programName: "Spotlight",
    stateHash: "default"
  };

  // 이미 존재하면 스킵
  const existing = await this.storage.getNode(spotlightNodeId);
  if (existing) return;

  // Spotlight 기본 노드 생성
  const spotlightNode: Node = {
    id: spotlightNodeId,
    metadata: {
      title: "macOS Spotlight Search",
      description: "Default system search interface accessible via Cmd+Space",
      uiElements: [{ type: "input", text: "Spotlight Search" }],
      createdAt: new Date(),
      lastVisitedAt: new Date(),
      visitCount: 0
    },
    childrenIds: []
  };

  await this.storage.addNode(spotlightNode);
  this.graph.nodes.set(nodeIdToKey(spotlightNodeId), spotlightNode);
}
```

#### 2. identifyCurrentNode(): Promise<NodeId | null>

현재 화면의 노드를 식별합니다.

**시그니처**:
```typescript
async identifyCurrentNode(): Promise<NodeId | null>
```

**내부 로직 (단계별)**:

```typescript
async identifyCurrentNode(): Promise<NodeId | null> {
  try {
    // 1. 화면 캡처
    const pngBuffer = this.captureScreenBuffer();
    const base64Image = pngBuffer.toString('base64');

    // 2. OCR 분석 (macOS Vision Framework)
    let ocrData: OCRAnalysis | undefined = undefined;
    if (OCRFactory.isSupported()) {
      const ocrProvider = OCRFactory.create();
      if (ocrProvider) {
        ocrData = await ocrProvider.analyzeBuffer(pngBuffer);
        // ocrData = { fullText: "...", elements: [{text, confidence, bbox}] }
      }
    }

    // 3. VLM으로 프로그램명 추출
    const programName = await this.vlmAnalyzer.extractProgramName(
      base64Image,
      ocrData
    );
    // 예: "Chrome", "Finder", "Terminal", etc.

    // 4. VLM으로 UI 요소 식별
    const { elements, description } = await this.vlmAnalyzer.identifyUIElements(
      base64Image,
      ocrData
    );
    // elements: [{ type: "button", text: "Submit", bbox: {...} }, ...]

    // 5. 상태 해시 생성
    const stateHash = StateHasher.hashElements(elements);
    // stateHash: SHA-256 hash of normalized elements

    const nodeId: NodeId = {
      programName,
      stateHash
    };

    console.log(
      `[Brain] Current node: ${programName}::${stateHash} (${elements.length} elements)`
    );
    console.log(`[Brain] Description: ${description}`);

    // 6. ShadowDOM 업데이트
    await this.updateShadowDOM(nodeId);

    return nodeId;
  } catch (error) {
    console.error(`[Brain] Failed to identify current node: ${error.message}`);
    return null;
  }
}
```

**주요 특징**:
- **OCR + VLM 조합**: OCR로 텍스트 추출, VLM으로 시각적 요소 인식
- **상태 해시**: UI 요소를 정규화하고 해싱하여 노드 식별
- **자동 ShadowDOM 업데이트**: 식별 후 현재 상태를 ShadowDOM에 저장

#### 3. updateShadowDOM(nodeId: NodeId): Promise<void>

현재 화면 상태를 ShadowDOM에 업데이트합니다 (Private).

**시그니처**:
```typescript
private async updateShadowDOM(nodeId: NodeId): Promise<void>
```

**내부 로직**:
```typescript
private async updateShadowDOM(nodeId: NodeId): Promise<void> {
  console.log('[Brain] Updating ShadowDOM...');

  try {
    // 1. 화면 캡처
    const pngBuffer = this.captureScreenBuffer();
    const base64Screenshot = pngBuffer.toString('base64');

    // 2. OCR 분석
    let ocrResult: OCRAnalysis | undefined;
    if (OCRFactory.isSupported()) {
      const ocrProvider = OCRFactory.create();
      if (ocrProvider) {
        ocrResult = await ocrProvider.analyzeBuffer(pngBuffer);
      }
    }

    // 3. VLM 분석 (UI 요소)
    const { elements, description } = await this.vlmAnalyzer.identifyUIElements(
      base64Screenshot,
      ocrResult
    );

    // 4. 인스턴스 해시 생성 (노드 stateHash와 다름)
    // Node.stateHash는 정적, instanceHash는 런타임마다 다를 수 있음
    const instanceHash = StateHasher.hashElements(elements);

    // 5. ShadowDOM 생성
    this.shadowDOM = {
      nodeId,
      capturedAt: new Date(),
      screenshot: base64Screenshot,
      uiElements: elements,
      ocrResult,
      vlmDescription: description,
      instanceHash
    };

    console.log(
      `[Brain] ShadowDOM updated: ${elements.length} elements, instance: ${instanceHash.substring(0, 8)}...`
    );
  } catch (error) {
    console.error(`[Brain] Failed to update ShadowDOM: ${error.message}`);
    this.shadowDOM = null;
  }
}
```

**호출 시점**:
1. `identifyCurrentNode()` 후
2. 각 액션 실행 후 (`executePath()` 내부)

**Node.stateHash vs ShadowDOM.instanceHash**:
- **Node.stateHash**: 정적인 노드 식별자 (영구 저장)
- **ShadowDOM.instanceHash**: 런타임 인스턴스 식별자 (휘발성, 동적 컨텐츠 포함)

#### 4. addNode(nodeId: NodeId, metadata?): Promise<Node | null>

새 노드를 그래프에 추가하거나 기존 노드를 업데이트합니다.

**시그니처**:
```typescript
async addNode(
  nodeId: NodeId,
  metadata?: Partial<Node["metadata"]>
): Promise<Node | null>
```

**내부 로직**:
```typescript
async addNode(nodeId: NodeId, metadata?): Promise<Node | null> {
  if (!this.graph) {
    console.error("[Brain] Brain not initialized");
    return null;
  }

  try {
    // 1. 기존 노드 확인
    const existing = await this.storage.getNode(nodeId);
    if (existing) {
      // 방문 횟수 업데이트
      existing.metadata.lastVisitedAt = new Date();
      existing.metadata.visitCount++;
      await this.storage.updateNode(existing);
      this.graph.currentNodeId = nodeId;
      return existing;
    }

    // 2. 새 노드 생성
    const node: Node = {
      id: nodeId,
      metadata: {
        title: metadata?.title,
        screenshot: metadata?.screenshot,
        uiElements: metadata?.uiElements || [],
        description: metadata?.description,
        createdAt: new Date(),
        lastVisitedAt: new Date(),
        visitCount: 1
      },
      childrenIds: []
    };

    // 3. 스토리지 및 메모리에 저장
    await this.storage.addNode(node);
    this.graph.nodes.set(nodeIdToKey(nodeId), node);
    this.graph.currentNodeId = nodeId;

    console.log(
      `[Brain] Added new node: ${nodeId.programName}::${nodeId.stateHash}`
    );

    return node;
  } catch (error) {
    console.error(`[Brain] Failed to add node: ${error.message}`);
    return null;
  }
}
```

#### 5. learnPath(targetDescription: string): Promise<Path | null>

VLM이 현재 노드에서 목표로 가는 경로를 학습합니다.

**시그니처**:
```typescript
async learnPath(targetDescription: string): Promise<Path | null>
```

**내부 로직**:
```typescript
async learnPath(targetDescription: string): Promise<Path | null> {
  if (!this.graph || !this.graph.currentNodeId) {
    console.error("[Brain] No current node");
    return null;
  }

  try {
    const fromNodeId = this.graph.currentNodeId;

    // 1. 현재 화면 캡처
    const pngBuffer = this.captureScreenBuffer();
    const base64Image = pngBuffer.toString('base64');

    // 2. OCR 데이터 수집
    let ocrData: OCRAnalysis | undefined = undefined;
    if (OCRFactory.isSupported()) {
      const ocrProvider = OCRFactory.create();
      if (ocrProvider) {
        ocrData = await ocrProvider.analyzeBuffer(pngBuffer);
      }
    }

    // 3. VLM에게 네비게이션 경로 요청
    console.log(`[Brain] Learning path to: ${targetDescription}`);
    const { actions, confidence } = await this.vlmAnalyzer.learnNavigationPath(
      base64Image,
      targetDescription,
      ocrData
    );

    // 4. Confidence 체크
    if (actions.length === 0 || confidence < 0.3) {
      console.error("[Brain] VLM could not determine navigation path");
      return null;
    }

    // 5. VLM 액션을 우리 Action 포맷으로 변환
    const pathActions: Action[] = actions.map((action) => ({
      id: randomUUID(),
      data: action.data as ActionData,
      description: action.description,
      retryOnFailure: true
    }));

    // 6. Path 객체 생성 (toNodeId는 실행 후에 결정됨)
    const path: Path = {
      id: randomUUID(),
      fromNodeId,
      toNodeId: { programName: "Unknown", stateHash: "pending" },
      actions: pathActions,
      validation: {
        expectedElements: [],
        timeout: 30000
      },
      metadata: {
        successRate: 0,
        lastUsed: new Date(),
        usageCount: 0,
        averageDuration: 0,
        learnedBy: "vlm"
      }
    };

    console.log(
      `[Brain] Learned path with ${pathActions.length} actions (confidence: ${confidence})`
    );

    return path;
  } catch (error) {
    console.error(`[Brain] Failed to learn path: ${error.message}`);
    return null;
  }
}
```

**VLM이 반환하는 액션 예시**:
```json
{
  "actions": [
    {
      "type": "click",
      "data": { "text": "Settings" },
      "description": "Click on Settings menu"
    },
    {
      "type": "wait",
      "data": { "milliseconds": 500 },
      "description": "Wait for UI to load"
    },
    {
      "type": "click",
      "data": { "text": "Display" },
      "description": "Click on Display option"
    }
  ],
  "confidence": 0.85
}
```

#### 6. executeAction(action: Action): Promise<boolean>

개별 액션을 실행합니다 (Private).

**시그니처**:
```typescript
private async executeAction(action: Action): Promise<boolean>
```

**지원하는 액션 타입**:
```typescript
type Action =
  | ClickAction     // 클릭
  | TypeAction      // 텍스트 입력
  | HotkeyAction    // 키보드 단축키
  | WaitAction      // 대기
  | ScrollAction;   // 스크롤
```

**내부 로직**:
```typescript
private async executeAction(action: Action): Promise<boolean> {
  try {
    console.log(
      `[Brain] Executing: ${action.data.type} - ${action.description || ""}`
    );

    switch (action.data.type) {
      case "click": {
        const clickData = action.data;

        // 좌표 기반 클릭
        if (clickData.x !== undefined && clickData.y !== undefined) {
          MouseController.clickAt(
            clickData.x,
            clickData.y,
            clickData.button,
            clickData.doubleClick
          );
        }
        // 텍스트 기반 클릭 (OCR)
        else if (clickData.text) {
          const pngBuffer = this.captureScreenBuffer();
          const ocrProvider = OCRFactory.create();
          if (!ocrProvider) {
            console.error("[Brain] OCR not available");
            return false;
          }

          const ocrResult = await ocrProvider.analyzeBuffer(pngBuffer);

          // OCR 결과에서 텍스트 매칭
          const matches = ocrResult.elements.filter((el) =>
            el.text.toLowerCase().includes(clickData.text!.toLowerCase())
          );

          if (matches.length === 0) {
            console.error(`[Brain] Text "${clickData.text}" not found`);
            return false;
          }

          // 신뢰도가 가장 높은 것 선택
          const bestMatch = matches.sort((a, b) => b.confidence - a.confidence)[0];
          if (bestMatch.bbox) {
            MouseController.clickBBoxCenter(
              bestMatch.bbox,
              clickData.button,
              clickData.doubleClick
            );
          }
        }
        await delay(200);
        break;
      }

      case "type": {
        const typeData = action.data;
        KeyboardController.typeText(typeData.text, typeData.delay);
        if (typeData.pressEnter) {
          await delay(100);
          KeyboardController.pressEnter();
        }
        await delay(200);
        break;
      }

      case "hotkey": {
        const hotkeyData = action.data;
        KeyboardController.pressKey(hotkeyData.key, hotkeyData.modifiers);
        await delay(200);
        break;
      }

      case "wait": {
        const waitData = action.data;
        await delay(waitData.milliseconds);
        break;
      }

      case "scroll": {
        const scrollData = action.data;
        MouseController.scroll(scrollData.amount, scrollData.direction);
        await delay(200);
        break;
      }

      default:
        console.error(`[Brain] Unknown action type: ${action.data.type}`);
        return false;
    }

    return true;
  } catch (error) {
    console.error(`[Brain] Action execution failed: ${error.message}`);
    return false;
  }
}
```

#### 7. executePath(path: Path): Promise<boolean>

경로를 실행합니다 (각 액션 순차 실행 + 검증).

**시그니처**:
```typescript
async executePath(path: Path): Promise<boolean>
```

**내부 로직 (단계별)**:
```typescript
async executePath(path: Path): Promise<boolean> {
  console.log(
    `[Brain] Executing path with ${path.actions.length} actions (success rate: ${path.metadata.successRate})`
  );

  const startTime = Date.now();
  let success = true;

  // 검증 이력 초기화
  if (!path.verificationHistory) {
    path.verificationHistory = [];
  }

  // 각 액션 순차 실행
  for (let i = 0; i < path.actions.length; i++) {
    const action = path.actions[i];

    // 1. 액션 실행
    const actionSuccess = await this.executeAction(action);

    if (!actionSuccess) {
      success = false;

      // 검증 실패 기록
      path.verificationHistory.push({
        timestamp: new Date(),
        success: false,
        actionIndex: i,
        failureReason: 'Action execution failed'
      });

      // 재시도 로직
      if (action.retryOnFailure) {
        console.log("[Brain] Retrying action...");
        await delay(1000);
        const retrySuccess = await this.executeAction(action);

        if (retrySuccess) {
          success = true;
          continue;
        }
      }

      console.error(
        "[Brain] Path execution failed at action:",
        action.description
      );
      break;
    }

    // 2. UI 안정화 대기
    await delay(500); // Wait for UI to stabilize

    // 3. ShadowDOM 업데이트
    const currentNodeId = this.graph?.currentNodeId || path.toNodeId;
    await this.updateShadowDOM(currentNodeId);

    // 4. 액션 결과 검증
    const verification = await this.verifyActionResult(path, i);
    path.verificationHistory.push(verification);

    if (!verification.success) {
      console.error(
        `[Brain] Verification failed after action ${i}: ${verification.failureReason}`
      );
      success = false;
      break;
    }
  }

  // 5. Path 메타데이터 업데이트
  const duration = Date.now() - startTime;
  path.metadata.usageCount++;
  path.metadata.lastUsed = new Date();

  // 성공률 업데이트 (이동 평균)
  if (success) {
    path.metadata.successRate =
      (path.metadata.successRate * (path.metadata.usageCount - 1) + 1) /
      path.metadata.usageCount;
  } else {
    path.metadata.successRate =
      (path.metadata.successRate * (path.metadata.usageCount - 1)) /
      path.metadata.usageCount;
  }

  // 평균 실행 시간 업데이트
  path.metadata.averageDuration =
    (path.metadata.averageDuration * (path.metadata.usageCount - 1) + duration) /
    path.metadata.usageCount;

  // 6. JSON에 저장
  try {
    await this.storage.updatePath(path);
  } catch (error) {
    console.error(`[Brain] Failed to update path metadata: ${error.message}`);
  }

  console.log(
    `[Brain] Path execution ${success ? "succeeded" : "failed"} (${duration}ms, success rate: ${path.metadata.successRate})`
  );

  return success;
}
```

**주요 특징**:
- **순차 실행**: 각 액션을 순서대로 실행
- **재시도**: `retryOnFailure` 플래그가 있으면 실패 시 1초 후 재시도
- **검증**: 각 액션 후 ShadowDOM 업데이트 + VLM 검증
- **메타데이터**: 성공률, 평균 실행 시간 자동 업데이트
- **영속화**: 경로 실행 후 JSON에 저장

#### 8. navigateTo(targetDescription: string): Promise<boolean>

목표로 네비게이션합니다 (경로 찾기 또는 학습).

**시그니처**:
```typescript
async navigateTo(targetDescription: string): Promise<boolean>
```

**내부 로직 (상세)**:
```typescript
async navigateTo(targetDescription: string): Promise<boolean> {
  if (!this.graph) {
    console.error("[Brain] Brain not initialized");
    return false;
  }

  console.log(`[Brain] Navigating to: ${targetDescription}`);

  // 1. 현재 노드 식별
  const currentNodeId = await this.identifyCurrentNode();
  if (!currentNodeId) {
    console.error("[Brain] Failed to identify current node");
    return false;
  }

  // 2. 기존 경로 검색 (JSON에서)
  const existingPaths = await this.storage.getPathsFrom(currentNodeId);

  // 경로 매칭 (targetDescription과 유사한 경로 찾기)
  const matchingPath = existingPaths.find((path) => {
    // 목표 노드 메타데이터와 targetDescription 비교
    // 또는 path.metadata에 저장된 목표 설명과 비교
    return /* 매칭 로직 */;
  });

  // 3-A. 기존 경로가 있으면 재사용
  if (matchingPath) {
    console.log(
      `[Brain] Found existing path (success rate: ${matchingPath.metadata.successRate})`
    );

    const success = await this.executePath(matchingPath);

    if (success) {
      // 도착 노드 식별
      const arrivedNodeId = await this.identifyCurrentNode();
      if (arrivedNodeId) {
        await this.addNode(arrivedNodeId);
      }
      return true;
    }

    // 경로 실행 실패 → 재학습
    console.log("[Brain] Path execution failed, relearning...");
  }

  // 3-B. 경로가 없거나 실패 → VLM이 새로 학습
  const newPath = await this.learnPath(targetDescription);
  if (!newPath) {
    console.error("[Brain] Failed to learn navigation path");
    return false;
  }

  // 4. 새 경로 실행
  const success = await this.executePath(newPath);
  if (!success) {
    console.error("[Brain] Failed to execute learned path");
    return false;
  }

  // 5. 도착 노드 식별 및 추가
  const arrivedNodeId = await this.identifyCurrentNode();
  if (!arrivedNodeId) {
    console.error("[Brain] Failed to identify arrival node");
    return false;
  }

  // 6. Path의 toNodeId 업데이트
  newPath.toNodeId = arrivedNodeId;

  // 7. 경로 저장
  await this.storage.addPath(newPath);
  if (this.graph) {
    this.graph.edges.set(newPath.id, newPath);
  }

  // 8. 노드 추가
  await this.addNode(arrivedNodeId, {
    title: targetDescription,
    screenshot: this.shadowDOM?.screenshot
      ? Buffer.from(this.shadowDOM.screenshot, 'base64')
      : undefined,
    uiElements: this.shadowDOM?.uiElements || [],
    description: this.shadowDOM?.vlmDescription
  });

  console.log(
    `[Brain] Successfully navigated to ${arrivedNodeId.programName}::${arrivedNodeId.stateHash}`
  );

  return true;
}
```

**실행 흐름 다이어그램**:

```
navigateTo("Settings")
    ↓
identifyCurrentNode()
    → currentNodeId: { programName: "Finder", stateHash: "abc123" }
    ↓
기존 경로 검색 (JSON)
    ├─ Found → executePath() → Success? → Return
    └─ Not Found → learnPath()
                      ↓
                   VLM 분석
                      ↓
                   actions: [click("Settings"), wait(500)]
                      ↓
                   executePath()
                      ↓
                   identifyCurrentNode()
                      → arrivedNodeId: { programName: "Settings", stateHash: "def456" }
                      ↓
                   addPath() → JSON 저장
                      ↓
                   addNode() → 도착 노드 추가
                      ↓
                   Return true
```

### 주요 메서드 요약

| 메서드 | 목적 | VLM 호출 | 스토리지 |
|--------|------|---------|----------|
| **initialize()** | 브레인 초기화 | X | JSON 로드 |
| **identifyCurrentNode()** | 현재 노드 식별 | O | - |
| **updateShadowDOM()** | 화면 상태 캐싱 | O | - |
| **addNode()** | 노드 추가/업데이트 | X | JSON 저장 |
| **learnPath()** | 경로 학습 | O | - |
| **executeAction()** | 액션 실행 | X | - |
| **executePath()** | 경로 실행 | O (검증) | JSON 업데이트 |
| **navigateTo()** | 네비게이션 | O (조건부) | JSON 추가/업데이트 |

---

## VLMAnalyzer (268줄)

**파일**: `src/brain/utils/VLMAnalyzer.ts` (268줄)

### 목적

VLMAnalyzer는 **VLM 분석 래퍼**로, Vision LLM을 사용하여 화면을 분석하는 4가지 메서드를 제공합니다.

### Public API

#### 1. extractProgramName(screenshot, ocrData?): Promise<string>

스크린샷에서 프로그램명을 추출합니다.

**시그니처**:
```typescript
async extractProgramName(
  screenshot: string,      // base64 PNG
  ocrData?: OCRAnalysis
): Promise<string>
```

**사용하는 LLM 모드**: `vision`

**프롬프트 예시**:
```
What is the name of the application shown in this screenshot?
Return only the application name (e.g., "Chrome", "Finder", "Terminal").

OCR Context: [OCR fullText...]
```

**반환 예시**: `"Chrome"`, `"Finder"`, `"Terminal"`

#### 2. identifyUIElements(screenshot, ocrData?): Promise<{elements, description}>

UI 요소를 식별합니다.

**시그니처**:
```typescript
async identifyUIElements(
  screenshot: string,
  ocrData?: OCRAnalysis
): Promise<{
  elements: UIElement[];
  description: string;
}>
```

**반환 예시**:
```json
{
  "elements": [
    {
      "type": "button",
      "text": "Submit",
      "bbox": { "x": 100, "y": 200, "width": 80, "height": 40 },
      "isClickable": true
    },
    {
      "type": "input",
      "text": "Enter your name",
      "bbox": { "x": 100, "y": 100, "width": 200, "height": 30 },
      "isInteractive": true
    }
  ],
  "description": "Login form with username input and submit button"
}
```

#### 3. learnNavigationPath(screenshot, toDescription, ocrData?): Promise<{actions, confidence}>

네비게이션 경로를 학습합니다.

**시그니처**:
```typescript
async learnNavigationPath(
  screenshot: string,
  toDescription: string,    // "Settings page", "Display settings", etc.
  ocrData?: OCRAnalysis
): Promise<{
  actions: VLMAction[];
  confidence: number;       // 0-1
}>
```

**프롬프트 예시**:
```
You are navigating a GUI. Current screen is shown in the screenshot.

Goal: Navigate to "Display settings"

OCR Context: [OCR fullText...]

Please provide a sequence of actions to reach the goal.
Return JSON:
{
  "actions": [
    { "type": "click", "data": { "text": "Settings" }, "description": "..." },
    { "type": "wait", "data": { "milliseconds": 500 }, "description": "..." }
  ],
  "confidence": 0.85
}
```

**반환 예시**:
```json
{
  "actions": [
    {
      "type": "click",
      "data": { "text": "System Preferences" },
      "description": "Click on System Preferences"
    },
    {
      "type": "wait",
      "data": { "milliseconds": 1000 },
      "description": "Wait for window to open"
    },
    {
      "type": "click",
      "data": { "text": "Displays" },
      "description": "Click on Displays option"
    }
  ],
  "confidence": 0.9
}
```

#### 4. verifyScreenState(screenshot, expectedElements, expectedTexts?): Promise<PathVerification>

화면 상태를 검증합니다.

**시그니처**:
```typescript
async verifyScreenState(
  screenshot: string,
  expectedElements: string[],
  expectedTexts?: string[]
): Promise<PathVerification>
```

**반환 예시**:
```json
{
  "timestamp": "2025-01-15T10:30:00Z",
  "success": true,
  "actionIndex": 2,
  "foundElements": ["Settings", "Display"],
  "missingElements": [],
  "confidence": 0.95
}
```

---

## StateHasher (103줄)

**파일**: `src/brain/utils/StateHasher.ts` (103줄)

### 목적

StateHasher는 **상태 해싱 및 유사도 계산** 유틸리티입니다.

### Public API

#### 1. hashElements(elements: UIElement[]): string

UI 요소 배열을 해싱합니다 (SHA-256).

**시그니처**:
```typescript
static hashElements(elements: UIElement[]): string
```

**내부 로직**:
```typescript
static hashElements(elements: UIElement[]): string {
  // 1. 요소 정규화 (normalize)
  const normalized = elements.map((el) => ({
    type: el.type,
    text: el.text?.toLowerCase().trim(),
    role: el.role?.toLowerCase()
  }));

  // 2. 정렬 (sort)
  normalized.sort((a, b) => {
    if (a.type !== b.type) return a.type.localeCompare(b.type);
    if (a.text !== b.text) return (a.text || '').localeCompare(b.text || '');
    return (a.role || '').localeCompare(b.role || '');
  });

  // 3. JSON 문자열로 변환
  const jsonString = JSON.stringify(normalized);

  // 4. SHA-256 해시
  const hash = crypto.createHash('sha256').update(jsonString).digest('hex');

  return hash;
}
```

**예시**:
```typescript
const elements = [
  { type: 'button', text: 'Submit' },
  { type: 'input', text: 'Username' },
  { type: 'button', text: 'Cancel' }
];

const hash = StateHasher.hashElements(elements);
// → "a3f8d9e2c1b0..." (64-character hex)
```

#### 2. similarity(elements1, elements2): number

두 요소 배열의 유사도를 계산합니다 (Jaccard 유사도).

**시그니처**:
```typescript
static similarity(elements1: UIElement[], elements2: UIElement[]): number
```

**Jaccard 유사도 공식**:
```
J(A, B) = |A ∩ B| / |A ∪ B|
```

**반환값**: `0.0` (완전 다름) ~ `1.0` (완전 같음)

**예시**:
```typescript
const elements1 = [
  { type: 'button', text: 'Submit' },
  { type: 'input', text: 'Username' }
];

const elements2 = [
  { type: 'button', text: 'Submit' },
  { type: 'input', text: 'Password' }
];

const sim = StateHasher.similarity(elements1, elements2);
// → 0.5 (2개 중 1개 일치)
```

#### 3. extractKeyFeatures(elements): object

주요 특징을 추출합니다.

**시그니처**:
```typescript
static extractKeyFeatures(elements: UIElement[]): {
  textCount: number;
  buttonCount: number;
  inputCount: number;
  linkCount: number;
  uniqueTexts: string[];
}
```

**예시**:
```typescript
const features = StateHasher.extractKeyFeatures(elements);
// {
//   textCount: 5,
//   buttonCount: 2,
//   inputCount: 1,
//   linkCount: 3,
//   uniqueTexts: ["Submit", "Cancel", "Username", "Password"]
// }
```

---

## 스토리지 시스템

### BrainStorage (67줄)

**파일**: `src/brain/storage/BrainStorage.ts` (67줄)

**추상 인터페이스**로, 다양한 스토리지 백엔드를 지원하기 위한 추상 클래스입니다.

```typescript
export abstract class BrainStorage {
  abstract load(): Promise<NavigationGraph | null>;
  abstract save(graph: SerializableNavigationGraph): Promise<void>;

  abstract addNode(node: Node): Promise<void>;
  abstract getNode(nodeId: NodeId): Promise<Node | null>;
  abstract updateNode(node: Node): Promise<void>;

  abstract addPath(path: Path): Promise<void>;
  abstract getPath(pathId: string): Promise<Path | null>;
  abstract getPathsFrom(fromNodeId: NodeId): Promise<Path[]>;
  abstract updatePath(path: Path): Promise<void>;
}
```

### JSONStorage (256줄)

**파일**: `src/brain/storage/JSONStorage.ts` (256줄)

JSON 파일 기반 영속성 구현입니다.

**파일 경로**: `data/brain/navigation.json`

**Serialization 이슈**:
- `Map` → `Array` (JSON은 Map을 지원하지 않음)
- `Date` → ISO 문자열
- `Buffer` → base64 문자열

**주요 메서드**:

#### load(): Promise<NavigationGraph | null>

```typescript
async load(): Promise<NavigationGraph | null> {
  if (!fs.existsSync(this.filePath)) {
    // 파일이 없으면 빈 그래프 생성
    return {
      nodes: new Map(),
      edges: new Map(),
      currentNodeId: null
    };
  }

  const jsonData = fs.readFileSync(this.filePath, 'utf-8');
  const serialized: SerializableNavigationGraph = JSON.parse(jsonData);

  // Deserialization
  const graph: NavigationGraph = {
    nodes: new Map(serialized.nodes.map((node) => [
      nodeIdToKey(node.id),
      {
        ...node,
        metadata: {
          ...node.metadata,
          createdAt: new Date(node.metadata.createdAt),
          lastVisitedAt: new Date(node.metadata.lastVisitedAt)
        }
      }
    ])),
    edges: new Map(serialized.edges.map((path) => [
      path.id,
      {
        ...path,
        metadata: {
          ...path.metadata,
          lastUsed: new Date(path.metadata.lastUsed)
        }
      }
    ])),
    currentNodeId: serialized.currentNodeId
  };

  return graph;
}
```

#### save(graph): Promise<void>

```typescript
async save(graph: SerializableNavigationGraph): Promise<void> {
  fs.writeFileSync(
    this.filePath,
    JSON.stringify(graph, null, 2),
    'utf-8'
  );
}
```

---

## Brain Tools (3개)

### NavigateToTool (85줄)

**파일**: `src/brain/tools/NavigateToTool.ts` (85줄)

**Tool 정의**:
```typescript
{
  name: 'navigate_to',
  description: '목표 화면으로 자동 네비게이션합니다',
  inputSchema: {
    type: 'object',
    properties: {
      target: {
        type: 'string',
        description: '목표 화면 설명 (예: "Settings page", "Display settings")'
      }
    },
    required: ['target']
  }
}
```

**execute()**:
```typescript
async execute(input: { target: string }): Promise<ToolResult> {
  const success = await this.brain.navigateTo(input.target);

  if (success) {
    return {
      success: true,
      data: `Successfully navigated to: ${input.target}`
    };
  } else {
    return {
      success: false,
      error: `Failed to navigate to: ${input.target}`
    };
  }
}
```

### GetCurrentNodeTool (82줄)

**Tool 정의**:
```typescript
{
  name: 'get_current_node',
  description: '현재 화면의 노드 정보를 조회합니다',
  inputSchema: {
    type: 'object',
    properties: {}
  }
}
```

**execute()**:
```typescript
async execute(): Promise<ToolResult> {
  const nodeId = await this.brain.identifyCurrentNode();
  const shadowDOM = this.brain.getShadowDOM();

  if (!nodeId) {
    return { success: false, error: 'Failed to identify current node' };
  }

  return {
    success: true,
    data: {
      nodeId,
      elementCount: shadowDOM?.uiElements.length || 0,
      description: shadowDOM?.vlmDescription,
      instanceHash: shadowDOM?.instanceHash
    }
  };
}
```

### LaunchAppTool (106줄)

**Tool 정의**:
```typescript
{
  name: 'launch_app',
  description: 'Spotlight를 통해 앱을 실행합니다',
  inputSchema: {
    type: 'object',
    properties: {
      appName: {
        type: 'string',
        description: '실행할 앱 이름 (예: "Calculator", "Terminal")'
      }
    },
    required: ['appName']
  }
}
```

**execute()**:
```typescript
async execute(input: { appName: string }): Promise<ToolResult> {
  // 1. Spotlight 실행 (Cmd+Space)
  KeyboardController.pressKey('space', ['command']);
  await delay(500);

  // 2. 앱 이름 입력
  KeyboardController.typeText(input.appName);
  await delay(300);

  // 3. Enter 입력
  KeyboardController.pressEnter();
  await delay(1000);

  // 4. 앱 실행 확인
  const nodeId = await this.brain.identifyCurrentNode();

  if (nodeId && nodeId.programName.toLowerCase().includes(input.appName.toLowerCase())) {
    return {
      success: true,
      data: `Successfully launched: ${input.appName}`
    };
  } else {
    return {
      success: false,
      error: `Failed to launch: ${input.appName}`
    };
  }
}
```

---

## 핵심 개념

### 1. 노드 (Node) vs 섀도우DOM (ShadowDOM)

| 구분 | 노드 (Node) | 섀도우DOM (ShadowDOM) |
|------|-------------|------------------------|
| **개념** | 정적인 "장소" | 런타임 스냅샷 |
| **식별** | `programName` + `stateHash` | `nodeId` + `instanceHash` |
| **저장** | JSON 파일 (영구) | 메모리 (휘발성) |
| **목적** | 네비게이션 그래프의 정점 | 현재 화면 상태 추적 |
| **내용** | 메타데이터 (title, createdAt, visitCount) | 스크린샷, UI 요소, OCR 결과 |
| **생성 시점** | `addNode()` 호출 시 | `updateShadowDOM()` 호출 시 |
| **업데이트** | 방문 시마다 visitCount 증가 | 화면 변경 시마다 |

**예시**:

```typescript
// Node (정적)
{
  id: { programName: "Chrome", stateHash: "a3f8d9e2..." },
  metadata: {
    title: "Chrome Browser",
    createdAt: "2025-01-10T10:00:00Z",
    lastVisitedAt: "2025-01-15T14:30:00Z",
    visitCount: 5
  },
  childrenIds: [...]
}

// ShadowDOM (동적)
{
  nodeId: { programName: "Chrome", stateHash: "a3f8d9e2..." },
  capturedAt: "2025-01-15T14:30:15Z",
  screenshot: "iVBORw0KGgoAAAANS...",  // base64 PNG
  uiElements: [
    { type: "button", text: "Submit", bbox: {...} },
    { type: "input", text: "Search", bbox: {...} }
  ],
  ocrResult: { fullText: "...", elements: [...] },
  vlmDescription: "Chrome browser showing a search page",
  instanceHash: "b4e2f1c3..."  // 다를 수 있음
}
```

**핵심 차이**:
- **Node.stateHash**: UI 요소의 정규화된 해시 (정적)
- **ShadowDOM.instanceHash**: 런타임 인스턴스 해시 (동적 컨텐츠 포함)

예: Chrome에서 같은 페이지를 방문해도, 광고 배너나 타임스탬프 등 동적 요소 때문에 `instanceHash`는 매번 달라질 수 있지만, `stateHash`는 같습니다.

### 2. 경로 학습 및 재사용

```
[첫 번째 실행: "시스템 환경설정 → 디스플레이"]
    ↓
1. identifyCurrentNode() → Finder
2. 기존 경로 없음 → learnPath()
3. VLM 분석: "Click System Preferences, Wait, Click Displays"
4. executePath(): 각 액션 실행 + 검증
5. identifyCurrentNode() → Settings/Display
6. addPath() → JSON 저장
    ↓
비용: $0.15 (Vision mode)
시간: 5초

[두 번째 실행: "다시 디스플레이로"]
    ↓
1. identifyCurrentNode() → Finder
2. JSON에서 경로 발견!
3. executePath(): VLM 없이 바로 실행
4. OCR로 도착 검증만
    ↓
비용: $0.00 (VLM 미사용)
시간: 2초

결과: 비용 100% 절감, 속도 150% 빠름!
```

### 3. VLM 호출 최소화 전략

| 상황 | VLM 호출 | 비용 |
|------|----------|------|
| **첫 방문** | 필수 (경로 학습) | 높음 ($0.15) |
| **재방문** | 불필요 (JSON 사용) | 없음 ($0.00) |
| **경로 실패** | 필수 (재학습) | 높음 ($0.15) |
| **검증** | 선택적 (OCR 우선) | 낮음 ($0.02) |

**최적화 기법**:
1. **OCR 우선**: 텍스트 기반 작업은 OCR만 사용
2. **경로 재사용**: JSON에 저장된 경로 최대한 활용
3. **검증 최소화**: ShadowDOM 캐싱으로 중복 캡처 방지
4. **Confidence 체크**: VLM confidence < 0.3이면 학습 중단

---

## 사용 예시

### 기본 사용

```typescript
import { NavigationBrain } from './brain/NavigationBrain';
import { JSONStorage } from './brain/storage/JSONStorage';
import { LLMManager } from './llm/LLMManager';

// 1. 초기화
const storage = new JSONStorage();
const llmManager = new LLMManager(config);
const brain = new NavigationBrain(storage, llmManager);

await brain.initialize();

// 2. 현재 노드 식별
const nodeId = await brain.identifyCurrentNode();
console.log(`Current: ${nodeId.programName}::${nodeId.stateHash}`);

// 3. 네비게이션
const success = await brain.navigateTo("Display settings");
if (success) {
  console.log("Navigation successful!");
}

// 4. ShadowDOM 조회
const shadowDOM = brain.getShadowDOM();
console.log(`Elements: ${shadowDOM.uiElements.length}`);
console.log(`Description: ${shadowDOM.vlmDescription}`);
```

### 경로 학습 및 실행

```typescript
// 경로 학습
const path = await brain.learnPath("Go to Terminal preferences");

if (path) {
  console.log(`Learned ${path.actions.length} actions`);

  // 경로 실행
  const success = await brain.executePath(path);

  if (success) {
    console.log(`Success rate: ${path.metadata.successRate}`);
    console.log(`Duration: ${path.metadata.averageDuration}ms`);
  }
}
```

### 노드 및 경로 조회

```typescript
// 모든 노드 조회
const allNodes = await brain.getAllNodes();
console.log(`Total nodes: ${allNodes.length}`);

// 특정 노드에서 나가는 경로 조회
const paths = await brain.getPathsFrom(currentNodeId);
console.log(`Available paths: ${paths.length}`);

for (const path of paths) {
  console.log(`To: ${path.toNodeId.programName}`);
  console.log(`Actions: ${path.actions.length}`);
  console.log(`Success rate: ${path.metadata.successRate}`);
}
```

---

## 요약

### NavigationBrain
- **역할**: GUI 네비게이션 학습 및 실행 엔진
- **핵심 메서드**: initialize, identifyCurrentNode, navigateTo, learnPath, executePath
- **VLM 최적화**: 한 번 학습한 경로는 JSON 저장하여 재사용
- **그래프 구조**: Nodes (장소) + Paths (이동 방법)
- **ShadowDOM**: 런타임 화면 상태 캐싱

### 비용 최적화
- 첫 방문: VLM 사용 ($0.15)
- 재방문: VLM 미사용 ($0.00)
- 100% 비용 절감 가능!

### 핵심 통찰
1. **Node ≠ ShadowDOM**: 정적 vs 동적
2. **경로 재사용**: 그래프 기반 네비게이션
3. **OCR + VLM 시너지**: 정확도와 비용 최적화
4. **검증 시스템**: 각 액션 후 화면 상태 확인

브레인 시스템은 GAI의 가장 혁신적인 부분으로, GUI 자동화의 새로운 패러다임을 제시합니다.

---

다음 문서: [04-LLM시스템.md](04-LLM시스템.md)
